<div style="display:none"><math>

  \newcommand{\ordinarycolon}{:}
  \newcommand{\vcentcolon}{\mathrel{\mathop\ordinarycolon}}
  \newcommand{\coloneqq}{\vcentcolon{\mathrel{\mkern-1.2mu}}=}

  \newcommand{\nil}{[{\mkern3.0mu}]}
  \newcommand{\cons}{\vcentcolon{\mathrel{\mkern-1.2mu}}\vcentcolon}
  \newcommand{\append}{+{\mathrel{\mkern-3.0mu}}+}

</math></div>

この記事ではY数列 Hexirp 版の定義群を記述している。

== 名称の経緯 ==

Y数列はゆきと ([[ユーザー:ゆきと]], [https://twitter.com/Y_Y_Googology Twitter: @Y_Y_Googology]) 氏により作成された表記である。「階差を展開する」のが基本的なアイデアであり、 <math> (1,3) </math> の時点で[[バシク行列システム]]の限界と一致すると解析されている。さらに <math> (1,1), (1,2), (1,3), (1,4), \ldots </math> の極限（この列を展開列として持つ表記）は <math> ( 1, \omega ) </math> と表記される。これがY数列の限界である。その増加速度は非常に大きいとみられているが、あまりにも巨大すぎるため詳しいことはわかっていない。

その正確な定義はまだ完成していない。Y数列（のアイデアと理想の展開例）が Twitter や Discord を通じて広められると、日本語圏や英語圏の人々が正確な定義を作成することを試みるようになった。その様子は p進大好きbot 氏が例えるに「Y数列の定義合戦」である<ref>[https://twitter.com/non_archimedean/status/1174451173799018496 @non_archimedean - 2019/9/19]</ref>。

この時期に公開されたY数列関係の定義は以下のとおりである。

* ゆきと (2019/5/16) - [https://docs.google.com/document/d/1dA3V_5ZMfXN-z3X-g-yoJfmoTvKuk3efeaKaBFw8Vhs/edit?usp=sharing Y sequence　定義]
* Hexirp (2019/9/4) - [[ユーザーブログ:Hexirp/Y数列の定義]]

このような状況の下、9月19日にゆきと氏から以下のようなコメントがあった。<ref>[https://twitter.com/Y_Y_Googology/status/1174525344507817984 @Y_Y_Googology - 2019/9/19]</ref>

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">

バージョンを増やされるのは最も嫌いです
Y数列はY数列、一つであるべき
みんなが考えるのは良いですが、最終的にはひとつにまとめてほしい
って誰かdiscordで言って欲しいな。。

</div>

このコメント以降のY数列に類似する表記の定義はY数列という名前を使っていない。Y数列のオリジナルと一致しないため、Y数列を名乗ろうとすると「別バージョン」となってしまうためであろうか。

* p進大好きbot (2019/9/19) - [https://googology.wikia.org/wiki/User_blog:P%E9%80%B2%E5%A4%A7%E5%A5%BD%E3%81%8Dbot/New_Difference_Sequence_System User blog:P進大好きbot/New Difference Sequence System]
* Syst3ms (2019/9/28) - [https://googology.wikia.org/wiki/User_blog:Syst3ms/Bismuth_:_not_Y_sequence,_but_close User blog:Syst3ms/Bismuth : not Y sequence, but close]

また、これらと別にゆきと氏の[[東方巨大数]]3に投稿された定義を数式で形式化しようとする試みも存在する。

* Koteitan (2019/10/8) - [[ユーザーブログ:Koteitan/(1,3)未満のY数列の定義]]

翻って私が投稿した記事を見ると、Y数列の定義と書いている。しかし、明確に異なる展開をする定義を別バージョンとして意図的に作ろうとしていた。これでは、ゆきと氏の意思にそぐわないのではないかと私は考えた。そのため、記事を移動することにした。

しかし、Y数列の定義を目指している以上、Y数列を名称の一部に含まないのは私として違和感がある。これについて以前にこのような質問をしたことがある。

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">

私、 (1,2,4,8,10,8) の展開が別になっていて、それでいて定義が自然なものを見つけているんですが、その辺りは Y数列 Hexirp 版 b 版とでも書いておいて、Yukito さんが気に入ったら、 Yukito さんが公式に Y数列 x.y 版 とナンバリングするという形でいいんですかね

</div>

それに対するゆきと氏の答えはこの通りである。

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">

そんな感じでいいんじゃないですかね。。
すみません、僕もY数列どうしたいのかイマイチよく分かってなくて。。
しっかり温めて置いてください。必ず見ますので

</div>

私はこの回答を受けて、この記事に「Y数列 Hexirp 版」というタイトルをつけることにした。

== DPN形式について ==

DPN (Diff, Parent, and Depth) 形式は、Y数列 Hexirp 版の定義を記述するにあたって中核とした概念である。その基本的なアイデアは、Y数列の展開が山（差分を取り上に書き並べていく図）で説明されているのをみたときの体験にある。その時、どこが展開されて新しい山の元になるのか、どこが無視されて新しい山では使われないのかわからなかったのだ。

[[]]

上の画像で青い線で囲まれているのが展開される部分である。他の部分は無視され、後に再構成される。

このように、捨てられる部分があるのであれば、わかりやすく、その部分は除いてしまえばいいのではないか。その発想がDPN形式の始まりである。最初は Diff と Parent の二つしか含んでいなかったが、すぐに Depth も加わった。このとき、頭文字がかぶってしまったため、数式の中では Depth を主に n で表すようになった。これが DPN という名前の由来である。

[[]]

次の大きな変化は Parent が複数含まれるようになったことだ。これは (1,2,4,8,10,8) の展開を考察する途中で必要に迫られて加わった。上の画像を見てもらえばわかるように、この数列では親が途中で変わる。そうなるように、バシク行列システムの Upper-branch ignoring モデルを参考にして親の定義を定めた。そっちのほうが自然だったからだ。すると、この例の展開にみられるように、親の変化の履歴も保存する必要が生じた。こうして、複数の親を含めることを許すようになった。DPN形式は親が変化し始めてから最大の深さに到達するまでの親を全て記録する。

ちなみに、わかりづらいかもしれないが山の上の方になるほど「深い」としている。これは私がDPN形式を開発していた時は差分を下の方へ伸ばしていたためであるが、「山の奥深く」といった言葉があるため上の方に差分を書いていくときでも使えると思っている。

元の記事では、数列からDPN形式の変換とDPN形式から数列の変換は完成している。未完成なのはDPN形式からDPN形式の展開のみである。

== Y数列の性質 ==

仮定として、Y数列は辞書式順序によって大小比較が可能であることを置いている。この仮定に従わないように見える例も見つけることができる。例えば <math> (1,2,4) </math> と <math> (1,2,3,5,7) </math> では辞書式順序と違って後者のほうが大きい。しかしながら、このような場合は非標準形が絡んでいるとみられる。この場合では後者が非標準形である。

== Y数列 Hexirp 版 1.0.0 ==

このバージョンは (1,3) 未満にしか定義されていない。

=== 型 ===

数列は自然数の列である。DPN形式は D, P, N のタプルの列である。リストは何らかの列である。数列とDPN形式は添字が 1 から始まるが、リストは添字が 0 から始まる。数列は丸括弧とコンマで表され、DPN形式は行列で表され、リストは角括弧とコンマで表される。いずれも基本構造は <math> \_ \cons \_, \nil </math> である。

数列やDPN形式に関係して現れる 0 は何らかの例外を示す。リストに関係して現れる 0 はそうでない。

=== 一般的な表記 ===

ゼロを含まない自然数全体の集合は以下のように表記する。

<math>
  \begin{eqnarray*}
    \mathbb{N} ^ + & = & \{ x \in \mathbb{N} \mid x \neq 0 \} \\
  \end{eqnarray*}
</math>

再帰により減少および増加していく引数の増減には以下のような表記を使う。

<math>
  \begin{eqnarray*}
    x ^ - & = & x - 1 \\
    x ^ + & = & x + 1 \\
  \end{eqnarray*}
</math>

数列に関する表記は以下のようになる。

<math>
  \begin{eqnarray*}
    X _ S & = & \mathrm{length} ( S ) \\
    S & = & ( S _ 1, S _ 2, \ldots, S _ { X _ S } ) \\
  \end{eqnarray*}
</math>

リストに関する表記は以下のように定義される。

<math>
  \begin{eqnarray*}
    [ x _ 0, x _ 1, \ldots, x _ n ] & = & x _ 0 \cons x _ 1 \cons \cdots \cons x _ n \cons \nil \\
  \end{eqnarray*}
</math>

DPN形式に関する表記は以下のようになる。

<math>
  \begin{eqnarray*}
    X _ Z & = & \mathrm{length} ( Z ) \\
    Z & \coloneqq &
      \left (
        \begin{array}{cccc}
          Z _ { 1, 1 } & Z _ { 1, 2 } & \cdots & Z _ { 1, X _ S } \\
          Z _ { 2, 1 } & Z _ { 2, 2 } & \cdots & Z _ { 2, X _ S } \\
          Z _ { 3, 1 } & Z _ { 3, 2 } & \cdots & Z _ { 3, X _ S } \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

=== 数列から山への展開 ===

数列から山への展開は既に完成している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    D _ S ( x, n ) & \coloneqq &
      \begin{cases}
        S _ x                                                    & ( n = 1                              ) \\
        0                                                        & ( n > 1 \land P _ S ( x, n ^ - ) = 0 ) \\
        D _ S ( x, n ^ - ) - D _ S ( P _ S ( x, n ^ - ), n ^ - ) & ( n > 1 \land P _ S ( x, n ^ - ) > 0 ) \\
      \end{cases} \\
    P _ S ( x, n ) & \coloneqq &
      \begin{cases}
        0                                                                                                                          & ( n = 1 \land D _ S ( x, n ) = 1 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \}                                           & ( n = 1 \land D _ S ( x, n ) > 1 ) \\
        0                                                                                                                          & ( n > 1 \land D _ S ( x, n ) = 0 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \land p \in \mathrm{Anc} _ S ( x, n ^ - ) \} & ( n > 1 \land D _ S ( x, n ) > 0 ) \\
      \end{cases} \\
    \mathrm{Anc} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                           & ( x = 0 ) \\
        \{ x \} \cup \mathrm{Anc} _ S ( P _ S ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

D (Diff) は差分を記述し、 P (Parent) はそれらの親を記述する。親を決定する際、バシク行列システムのバージョン 4 と同じように Upper-branch ignoring モデルを使う。その決定に必要になるため Anc (Ancestor) が補助関数として用意されている。

[[]]

=== 山からDPN形式への圧縮 ===

山からDPN形式への圧縮は既に完成している。圧縮の仕方は次の通りである。

第一に、どの深さで展開するか定める。

<math>
  \begin{eqnarray*}
    T _ S & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid D _ S ( X, n ) > 0 \} \\
    c _ S & \coloneqq & D _ S ( X, T _ S ) \\
    t _ S & \coloneqq &
      \begin{cases}
        T _ S - 1 & ( c _ S = 1 ) \\
        T _ S     & ( c _ S > 1 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

T はカットする部分の中で最も深いゼロではない要素の深さである。 c は T の要素の値であり、これが数列のクラスである。 t は展開する深さである。ここで c が 1 だと T - 1 になるが、それ以外ではそのままである。ここは (1,2,4,8) などを展開しようとするときに深さを 1 つ減らさないとできなかったため、こうなった。このような定義が必要なのは横へ展開するか斜めへ展開するかの違いが原因だと私は見ている。

第二に、どこからどこまで親のデータを保存するか決める。さっきもちらっと触れたが、「親が変化し始めてから最大の深さに到達するまでの親」が範囲である。

<math>
  \begin{eqnarray*}
    m            _ S ( x ) & \coloneqq & \min ( n _ S ( x ), u _ S ( x ) ) \\
    u            _ S ( x ) & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid P _ S ( x, 1 ) = P _ S ( x, n ) \} \\
    \mathrm{btm} _ S ( x ) & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid D _ S ( x, n ) > 0 \} \\
  \end{eqnarray*}
</math>

ここで最大の深さとは n である。 u は親が変化し始めた箇所である。補助関数として親が存在する最も深い深さを返す btm が用意されている。

第三に、DPN形式を構築する。

<math>
  \begin{eqnarray*}
    d _ S ( x ) & \coloneqq & D _ S ( x, n _ S ( x ) ) \\
    p _ S ( x ) & \coloneqq & \mathrm{map} ( \lambda v \ldotp P _ S ( x, v ), \mathrm{enumFromTo} ( m _ S ( x ), n _ S ( x ) ) ) \\
    n _ S ( x ) & \coloneqq & \min ( t _ S, \mathrm{btm} _ S ( x ) ) \\
  \end{eqnarray*}
</math>

ここで n は一番下に書かれているくせに他の個所から使われているので注意である。その意味は、さっきも書いた通り「最大の深さ」である。どのくらい深く潜れるか (btm) と展開の深さ (t) を合わせて決定する。 d ( x ) は n での D である。 p は m から n までの P のリストである。

=== DPN形式から山への解凍 ===

DPN形式から山への解凍は既に完成している。

<math>
  \begin{eqnarray*}
    d _ Z ( x ) & \coloneqq & Z _ { 1, x } \\
    p _ Z ( x ) & \coloneqq & Z _ { 2, x } \\
    n _ Z ( x ) & \coloneqq & Z _ { 3, x } \\
  \end{eqnarray*}
</math>

d, p, n はそれぞれ対応する要素へのアクセス関数である。

<math>
  \begin{eqnarray*}
    D _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        P _ Z ( x, n ^ + ) + D _ Z ( P _ Z ( x, n ), n ) & ( n < N _ Z ( x ) ) \\
        d _ Z ( x )                                      & ( n = N _ Z ( x ) ) \\
        0                                                & ( n > N _ Z ( x ) ) \\
      \end{cases} \\
    P _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( \mathrm{reverse} ( d _ Z ( x ) ), n _ Z ( x ) - n ) & ( n \leq N _ Z ( x ) ) \\
        0                                                                  & ( n >    N _ Z ( x ) ) \\
      \end{cases} \\
    \mathrm{idx} ( p, n ) & \coloneqq &
      \begin{cases}
        p _ a                                     & ( p = p _ a \cons \nil                           ) \\
        p _ a                                     & ( p = p _ a \cons \p _ b \cons p _ s \land n = 0 ) \\
        \mathrm{idx} ( p _ b \cons p _ s, n ^ - ) & ( p = p _ a \cons \p _ b \cons p _ s \land n > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

D, P は言わずもがな山を作る関数である。補助関数として idx という親のリストから目的の親を取り出すための関数がある。

=== 山から数列への変換 ===

山から数列への変換は既に完成している。

<math>
  \begin{eqnarray*}
    S & \coloneqq & \mathrm{map} ( \lambda x \ldotp D _ Z ( x, 1 ), \mathrm{enumFromTo} ( 1, X ) ) \\
  \end{eqnarray*}
</math>
