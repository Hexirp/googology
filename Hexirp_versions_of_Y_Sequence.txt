<div style="display:none"><math>

  \newcommand{\ordinarycolon}{:}
  \newcommand{\vcentcolon}{\mathrel{\mathop\ordinarycolon}}
  \newcommand{\coloneqq}{\vcentcolon\mathrel{\mkern-1.2mu}=}

  \newcommand{\nil}{[\mkern3.0mu]}
  \newcommand{\cons}{\vcentcolon\mathrel{\mkern-1.2mu}\vcentcolon}
  \newcommand{\append}{\mathrel{{+}\mkern-3.0mu{+}}}

</math></div>

この記事ではY数列 Hexirp 版の定義群を記述している。

== 名称の経緯 ==

Y数列はゆきと ([[ユーザー:ゆきと]], [https://twitter.com/Y_Y_Googology Twitter: @Y_Y_Googology]) 氏により作成された表記である。「階差を展開する」のが基本的なアイデアであり、 <math> (1,3) </math> の時点で[[バシク行列システム]]の限界と一致すると解析されている。さらに <math> (1,1), (1,2), (1,3), (1,4), \ldots </math> の極限（この列を展開列として持つ表記）があり、それは <math> ( 1, \omega ) </math> と表記される。これがY数列の限界である。その増加速度は非常に大きいとみられているが、あまりにも巨大すぎるため詳しいことはわかっていない。

その正確な定義はまだ完成していない。Y数列（のアイデアと理想の展開例）が Twitter や Discord を通じて広められると、日本語圏や英語圏の人々が正確な定義を作成することを試みるようになった。その様子は p進大好きbot 氏が例えるに「Y数列の定義合戦」である<ref>[https://twitter.com/non_archimedean/status/1174451173799018496 @non_archimedean - 2019/9/19]</ref>。

この時期に公開されたY数列関係の定義は以下のとおりである。

* ゆきと (2019/5/16) - [https://docs.google.com/document/d/1dA3V_5ZMfXN-z3X-g-yoJfmoTvKuk3efeaKaBFw8Vhs/edit?usp=sharing Y sequence　定義]
* Hexirp (2019/9/4) - [[ユーザーブログ:Hexirp/Y数列の定義]]

このような状況の下、9月19日にゆきと氏から以下のようなコメントがあった。<ref>[https://twitter.com/Y_Y_Googology/status/1174525344507817984 @Y_Y_Googology - 2019/9/19]</ref>

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">バージョンを増やされるのは最も嫌いです
Y数列はY数列、一つであるべき
みんなが考えるのは良いですが、最終的にはひとつにまとめてほしい
って誰かdiscordで言って欲しいな。。</div>

このコメント以降のY数列に類似する表記の定義はY数列という名前を使っていない。Y数列のオリジナルと一致しないため、Y数列を名乗ろうとすると「別バージョン」となってしまうためであろうか。

* p進大好きbot (2019/9/19) - [https://googology.wikia.org/wiki/User_blog:P%E9%80%B2%E5%A4%A7%E5%A5%BD%E3%81%8Dbot/New_Difference_Sequence_System User blog:P進大好きbot/New Difference Sequence System]
* Syst3ms (2019/9/28) - [https://googology.wikia.org/wiki/User_blog:Syst3ms/Bismuth_:_not_Y_sequence,_but_close User blog:Syst3ms/Bismuth : not Y sequence, but close]

また、これらと別にゆきと氏の[[東方巨大数]]3に投稿された定義を数式で形式化しようとする試みも存在する。

* Koteitan (2019/10/8) - [[ユーザーブログ:Koteitan/(1,3)未満のY数列の定義]]

翻って私が投稿した記事を見ると、Y数列の定義と書いている。しかし、明確に異なる展開をする定義を別バージョンとして意図的に作ろうとしていた。これでは、ゆきと氏の意思にそぐわないのではないかと私は考えた。そのため、記事を移動することにした。

しかし、Y数列の定義を目指している以上、Y数列を名称の一部に含まないのは私として違和感がある。これについて以前にこのような質問をしたことがある。

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">私、 (1,2,4,8,10,8) の展開が別になっていて、それでいて定義が自然なものを見つけているんですが、その辺りは Y数列 Hexirp 版 b 版とでも書いておいて、Yukito さんが気に入ったら、 Yukito さんが公式に Y数列 x.y 版 とナンバリングするという形でいいんですかね</div>

それに対するゆきと氏の答えはこの通りである。

<div style="margin: 1em 0; padding: 0 4em 0; white-space: pre-wrap;">そんな感じでいいんじゃないですかね。。
すみません、僕もY数列どうしたいのかイマイチよく分かってなくて。。
しっかり温めて置いてください。必ず見ますので</div>

私はこの回答を受けて、この記事に「Y数列 Hexirp 版」というタイトルをつけることにした。

== DPN形式について ==

DPN (Diff, Parent, and Depth) 形式は、Y数列 Hexirp 版の定義を記述するにあたって中核とした概念である。その基本的なアイデアは、Y数列の展開が山（差分を取り上に書き並べていく図）で説明されているのをみたときの体験にある。その時、どこが展開されて新しい山の元になるのか、どこが無視されて新しい山では使われないのかわからなかったのだ。

[https://raw.githubusercontent.com/Hexirp/googology/master/DPN_Form_1.png DPN_Form_1.png]

上の画像で青い線で囲まれているのが展開される部分である。他の部分は無視され、後に再構成される。

このように、捨てられる部分があるのであれば、わかりやすく、その部分は除いてしまえばいいのではないか。その発想がDPN形式の始まりである。最初は Diff と Parent の二つしか含んでいなかったが、すぐに Depth も加わった。このとき、頭文字がかぶってしまったため、数式の中では Depth を主に n で表すようになった。これが DPN という名前の由来である。

[https://raw.githubusercontent.com/Hexirp/googology/master/DPN_Form_2.png DPN_Form_2.png]

次の大きな変化は Parent が複数含まれるようになったことだ。これは (1,2,4,8,10,8) の展開を考察する途中で必要に迫られて加わった。上の画像を見てもらえばわかるように、この数列では親が途中で変わる。そうなるように、バシク行列システムの Upper-branch ignoring モデルを参考にして親の定義を定めた。そっちのほうが自然だったからだ。すると、この例の展開にみられるように、親の変化の履歴も保存する必要が生じた。こうして、複数の親を含めることを許すようになった。DPN形式は親が変化し始めてから最大の深さに到達するまでの親を全て記録する。

ちなみに、わかりづらいかもしれないが山の上の方になるほど「深い」としている。これは私がDPN形式を開発していた時は差分を下の方へ伸ばしていたためであるが、「山の奥深く」といった言葉があるため上の方に差分を書いていくときでも使えると思っている。

元の記事では、数列からDPN形式の変換とDPN形式から数列の変換は完成している。未完成なのはDPN形式からDPN形式の展開のみである。

== Y数列の性質 ==

仮定として、Y数列は辞書式順序によって大小比較が可能であることを置いている。この仮定に従わないように見える例も見つけることができる。例えば <math> (1,2,4) </math> と <math> (1,2,3,5,7) </math> では辞書式順序と違って後者のほうが大きい。しかしながら、このような場合は非標準形が絡んでいるとみられる。この場合では後者が非標準形である。

== Y数列 Hexirp 版 0.0 ==

以下の内容は[[ユーザーブログ:Hexirp/Y数列の定義]]として投稿されていたものである。だが前記の通りゆきと氏のコメントがあったため、ここの一部として移動された。

----

'''Y数列'''を数式で定義する。この定義は圧縮・展開・解凍の三段階を使っている。また、圧縮／解凍の形式は D (difference), P (parent), N (depth) の三行で構成された形式（DPN形式と名付けた）を使っている。

=== 現状 ===

この記事の定義は <math> ( 1, n ) </math> のY数列に対する定義であるが、現時点ではいくつかの異常が見つかっている。

* <math> ( 1, 2, 4, 8, 10, 8 ) </math> が意図通りに展開されない。これは展開の節の <math> \mathrm{idx} ( p, n ) </math> の定義を変更するだけで容易に解決する見込みであるが、現在の定義のほうも整合性を持っているため、修正した後もどこかに控えておきたいと思う。
* <math> ( 1, 3, 3, 2, 5, 6, 5 ) </math> が意図通りに展開されない。これは山が飛ぶ挙動が再現できていなかったためである。修正するのは難しそうだが近日中に修正する。

展開部はこのように未完成な状況だが、圧縮部と解凍部は既に完成している。

=== 汎用関数／表記 ===

<math>
  \begin{eqnarray*}
  x ^ - & \coloneqq & x - 1 \\
  x ^ + & \coloneqq & x + 1 \\
  \mathbb{N} ^ + & \coloneqq & \{ x \in \mathbb{N} \mid x \neq 0 \} \\
  [ x, \ldots, y ] & \coloneqq &
    \begin{cases}
      [ \,\, ]                          & ( x >    y ) \\
      [ x ] \frown [ x ^ +, \ldots, y ] & ( x \leq y ) \\
    \end{cases} \\
  \end{eqnarray*}
</math>

リスト版の内包表記も使っているが、定義を書ききる自信はないので Haskell でのリスト内包表記の動作を参考にしてほしい。

=== 圧縮 ===

ここでは <math> S </math> という数列を <math> Z </math> というDPN形式の行列へ圧縮する関数を記述している。また数列 <math> S </math> からクラスを表す自然数 <math> C </math> を求める関数も記述している。

山を構成する部分。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    S & = & ( S _ 1, S _ 2, \ldots, S _ X ) \\
    D _ S ( x, n ) & \coloneqq &
      \begin{cases}
        S _ x                                                    & ( n = 1                              ) \\
        0                                                        & ( n > 1 \land P _ S ( x, n ^ - ) = 0 ) \\
        D _ S ( x, n ^ - ) - D _ S ( P _ S ( x, n ^ - ), n ^ - ) & ( n > 1 \land P _ S ( x, n ^ - ) > 0 ) \\
      \end{cases} \\
    P _ S ( x, n ) & \coloneqq &
      \begin{cases}
        0                                                                                                                          & ( n = 1 \land D _ S ( x, n ) = 1 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \}                                           & ( n = 1 \land D _ S ( x, n ) > 1 ) \\
        0                                                                                                                          & ( n > 1 \land D _ S ( x, n ) = 0 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \land p \in \mathrm{Anc} _ S ( x, n ^ - ) \} & ( n > 1 \land D _ S ( x, n ) > 0 ) \\
      \end{cases} \\
    \mathrm{Anc} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                           & ( x = 0 ) \\
        \{ x \} \cup \mathrm{Anc} _ S ( P _ S ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

山をDPN形式へ圧縮する部分。

<math>
  \begin{eqnarray*}
    T _ S & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid D _ S ( X, n ) > 0 \} \\
    c _ S & \coloneqq & D _ S ( X, T _ S ) \\
    t _ S & \coloneqq &
      \begin{cases}
        T _ S - 1 & ( c _ S = 1 ) \\
        T _ S     & ( c _ S > 1 ) \\
      \end{cases} \\
    \mathrm{btm} _ S ( x ) & \coloneqq &
      \begin{cases}
        0                                                       & ( D _ S ( x, 1 ) = 1 ) \\
        \max \{ n \in \mathbb{N} ^ + \mid D _ S ( x, n ) > 0 \} & ( D _ S ( x, 1 ) > 1 ) \\
      \end{cases} \\
    u _ S ( x ) & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid P _ S ( x, 1 ) = P _ S ( x, n ) \land n \leq n _ S ( x ) \} \\
    v _ S ( x ) & \coloneqq & n _ S ( x ) \\
    d _ S ( x ) & \coloneqq & D _ S ( x, n _ S ( x ) ) \\
    p _ S ( x ) & \coloneqq & [ P _ S ( x, n ) \mid n \leftarrow [ u _ S ( x ), \ldots, v _ S ( x ) ] ] \\
    n _ S ( x ) & \coloneqq & \max ( \mathrm{btm} _ S ( x ), t _ S ) \\
  \end{eqnarray*}
</math>

DPN形式への圧縮を行う関数は以下のようになる。

<math>
  z ( S ) \coloneqq
    \left (
      \begin{array}{cccc}
        d _ S ( 1 ) & d _ S ( 2 ) & \cdots & d _ S ( X ) \\
        p _ S ( 1 ) & p _ S ( 2 ) & \cdots & p _ S ( X ) \\
        n _ S ( 1 ) & n _ S ( 2 ) & \cdots & n _ S ( X ) \\
      \end{array}
    \right )
</math>

また、付随して行列のクラスも必要な情報に含まれる。

<math>
  c ( S ) \coloneqq c _ S
</math>

この <math> z ( S ) </math> が <math> Z </math> となる。また <math> c ( S ) </math> が <math> C </math> となる。

=== 展開 ===

ここではDPN形式の行列 <math> S </math> とクラスを表す整数 <math> C </math> と展開数 <math> m </math> から展開済みのDPN形式の行列 <math> Z </math> を求める関数を記述する。

DPN形式の行列の要素へアクセスする関数の部分。

<math>
  \begin{eqnarray*}
    S & \coloneqq &
      \left (
        \begin{array}{cccc}
          S _ { 1, 1 } & S _ { 1, 2 } & \cdots & S _ { 1, X } \\
          S _ { 2, 1 } & S _ { 2, 2 } & \cdots & S _ { 2, X } \\
          S _ { 3, 1 } & S _ { 3, 2 } & \cdots & S _ { 3, X } \\
        \end{array}
      \right ) \\
    D _ S ( x ) & \coloneqq & S _ { 1, x } \\
    P _ S ( x ) & \coloneqq & S _ { 2, x } \\
    N _ S ( x ) & \coloneqq & S _ { 3, x } \\
  \end{eqnarray*}
</math>

良い部分と悪い部分と刈られた部分の分割の部分。

<math>
  \begin{eqnarray*}
    R _ S & \coloneqq & p _ a \quad ( P _ S ( X ) = p _ s \frown [ p _ a ] ) \\
    G _ S & \coloneqq &
      \left (
        \begin{array}{cccc}
          S _ { 1, 1 } & S _ { 1, 2 } & \cdots & S _ { 1, R _ S - 1 } \\
          S _ { 2, 1 } & S _ { 2, 2 } & \cdots & S _ { 2, R _ S - 1 } \\
          S _ { 3, 1 } & S _ { 3, 2 } & \cdots & S _ { 3, R _ S - 1 } \\
        \end{array}
      \right ) \\
    B _ S & \coloneqq &
      \left (
        \begin{array}{cccc}
          S _ { 1, R _ S - 1 + 1 } & S _ { 1, R _ S - 1 + 2 } & \cdots & S _ { 1, X - 1 } \\
          S _ { 2, R _ S - 1 + 1 } & S _ { 2, R _ S - 1 + 2 } & \cdots & S _ { 2, X - 1 } \\
          S _ { 3, R _ S - 1 + 1 } & S _ { 3, R _ S - 1 + 2 } & \cdots & S _ { 3, X - 1 } \\
        \end{array}
      \right ) \\
    C _ S & \coloneqq &
      \left (
        \begin{array}{c}
          S _ { 1, X } \\
          S _ { 2, X } \\
          S _ { 3, X } \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

下の <math> e ( S, C, n ) </math> が <math> Z </math> である。

==== クラス１ ====

悪い部分をコピーする部分。

<math>
  \begin{eqnarray*}
    \mathrm{idx} ( p, n ) & \coloneqq &
      \begin{cases}
        p _ a                                          & ( p =              [ p _ a ]                    ) \\
        p _ a                                          & ( p = p _ s \frown [ p _ b, p _ a ] \land n = 1 ) \\
        \mathrm{idx} ( p _ s \frown [ p _ b ], n ^ - ) & ( p = p _ s \frown [ p _ b, p _ a ] \land n > 1 ) \\
      \end{cases} \\
    \mathrm{pnt} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( P _ S ( x ), N _ S ( x ) + 1 - n ) & ( n \leq N _ S ( x ) ) \\
        0                                                 & ( n >    N _ S ( x ) ) \\
      \end{cases} \\
    \mathrm{anc} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                                      & ( x = 0 ) \\
        \{ x \} \cup \mathrm{anc} _ S ( \mathrm{pnt} _ S ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
    r _ S & \coloneqq & R _ S \\
    \delta _ S & \coloneqq & X - r _ S \\
    a _ S ( x, n ) & \coloneqq &
      \begin{cases}
        1 & ( r _ S \in    \mathrm{anc} _ S ( r _ S - 1 + x, n ) ) \\
        0 & ( r _ S \notin \mathrm{anc} _ S ( r _ S - 1 + x, n ) ) \\
      \end{cases} \\
    \mathrm{bas} _ S ( x ) & \coloneqq &
      \begin{cases}
        P _ S ( X )             & ( x = 1 ) \\
        P _ S ( r _ S - 1 + x ) & ( x > 1 ) \\
      \end{cases} \\
    \mathrm{ris} _ S ( m, x, p, n ) & \coloneqq &
      \begin{cases}
        [ p _ a + m \times \delta _ S \times a _ S ( x, n ) ]                                                              & ( p =              [ p _ a ]        ) \\
        \mathrm{ris} _ S ( m, p _ s \frown [ p _ b ], n ^ - ) \frown [ p _ a + m \times \delta _ S \times a _ S ( x, n ) ] & ( p = p _ s \frown [ p _ b, p _ a ] ) \\
      \end{cases} \\
    d _ S ( m, x ) & \coloneqq & D _ S ( r _ S - 1 + x ) \\
    p _ S ( m, x ) & \coloneqq &
      \begin{cases}
        \mathrm{ris} _ S ( m - 1, x, \mathrm{bas} _ S ( x ), N _ S ( r _ S - 1 + x ) ) & ( x = r _ S ) \\
        \mathrm{ris} _ S ( m, x, \mathrm{bas} _ S ( x ), N _ S ( r _ S - 1 + x ) )     & ( x > r _ S ) \\
      \end{cases} \\
    n _ S ( m, x ) & \coloneqq & N _ S ( r _ S - 1 + x ) \\
    B _ S ( m ) & \coloneqq &
      \left (
        \begin{array}{cccc}
          d _ S ( m, 1 ) & d _ S ( m, 2 ) & \cdots & d _ S ( m, X - r _ S ) \\
          p _ S ( m, 1 ) & p _ S ( m, 2 ) & \cdots & p _ S ( m, X - r _ S ) \\
          n _ S ( m, 1 ) & n _ S ( m, 2 ) & \cdots & n _ S ( m, X - r _ S ) \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

新しい行列を求める部分。

<math>
  e ( S, 1, m ) \coloneqq G _ S \frown B _ S \frown B _ S ( 1 ) \frown B _ S ( 2 ) \frown \cdots \frown B _ S ( m )
</math>

怒る親を求める部分。

<math>
  r ( S ) \coloneqq r _ S
</math>

==== クラスｎ ====

悪い部分をコピーする部分。

<math>
  \begin{eqnarray*}
    \mathrm{idx} ( p, n ) & \coloneqq &
      \begin{cases}
        p _ a                                          & ( p =              [ p _ a ]                    ) \\
        p _ a                                          & ( p = p _ s \frown [ p _ b, p _ a ] \land n = 1 ) \\
        \mathrm{idx} ( p _ s \frown [ p _ b ], n ^ - ) & ( p = p _ s \frown [ p _ b, p _ a ] \land n > 1 ) \\
      \end{cases} \\
    \mathrm{pnt} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( P _ S ( x ), N _ S ( x ) + 1 - n ) & ( n \leq N _ S ( x ) ) \\
        0                                                 & ( n >    N _ S ( x ) ) \\
      \end{cases} \\
    \mathrm{anc} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                                      & ( x = 0 ) \\
        \{ x \} \cup \mathrm{anc} _ S ( \mathrm{pnt} _ S ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
    \mathrm{npt} _ S ( x ) & \coloneqq &
      \begin{cases}
        0                                                                                                                & ( N _ S ( x ) = 1 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land N _ S ( p ) < N _ S ( x ) \land p \in \mathrm{anc} _ S ( x, 1 ) \} & ( N _ S ( x ) > 1 ) \\
      \end{cases} \\
    \mathrm{nan} _ S ( x ) & \coloneqq &
      \begin{cases}
        \emptyset                                                & ( x = 0 ) \\
        \{ x \} \cup \mathrm{nan} _ S ( \mathrm{npt} _ S ( x ) ) & ( x > 0 ) \\
      \end{cases} \\
    { B' } _ S & \coloneqq & \mathrm{expand} ( B _ S, m ) \\
    r _ S & \coloneqq & R _ S + ( r ( B _ S ) - 1 ) \\
    \delta _ S & \coloneqq & X - r _ S \\
    a _ S ( x, n ) & \coloneqq &
      \begin{cases}
        1 & ( r _ S \in    \mathrm{anc} _ S ( r _ S - 1 + x, n ) ) \\
        0 & ( r _ S \notin \mathrm{anc} _ S ( r _ S - 1 + x, n ) ) \\
      \end{cases} \\
    \mathrm{bas} _ S ( x ) & \coloneqq &
      \begin{cases}
        P _ S ( X )             & ( x = 1 ) \\
        P _ S ( r _ S - 1 + x ) & ( x > 1 ) \\
      \end{cases} \\
    \mathrm{ris} _ S ( m, x, p, n ) & \coloneqq &
      \begin{cases}
        [ p _ a + m \times \delta _ S \times a _ S ( x, n ) ]                                                              & ( p =              [ p _ a ]        ) \\
        \mathrm{ris} _ S ( m, p _ s \frown [ p _ b ], n ^ - ) \frown [ p _ a + m \times \delta _ S \times a _ S ( x, n ) ] & ( p = p _ s \frown [ p _ b, p _ a ] ) \\
      \end{cases} \\
    \epsilon _ S & \coloneqq & N _ S ( X ) - N _ S ( r _ S ) \\
    b _ S ( x ) & \coloneqq &
      \begin{cases}
        1 & ( r _ S \in    \mathrm{nan} _ S ( r _ S - 1 + x, n ) ) \\
        0 & ( r _ S \notin \mathrm{nan} _ S ( r _ S - 1 + x, n ) ) \\
      \end{cases} \\
    \mathrm{des} _ S ( m, x ) & \coloneqq & N _ S ( r _ S - 1 + x ) + m \times \epsilon _ S \times b _ S ( x ) \\
    d _ S ( m, x ) & \coloneqq & { { B' } _ S } _ { ( r _ S - R _ S ) + ( m - 1 ) \times ( X - r _ S ) + x } \\
    p _ S ( m, x ) & \coloneqq &
      \begin{cases}
        \mathrm{ris} _ S ( m - 1, x, \mathrm{bas} _ S ( x ), N _ S ( r _ S - 1 + x ) ) & ( x = r _ S ) \\
        \mathrm{ris} _ S ( m, x, \mathrm{bas} _ S ( x ), N _ S ( r _ S - 1 + x ) )     & ( x > r _ S ) \\
      \end{cases} \\
    n _ S ( m, x ) & \coloneqq & \mathrm{des} _ S ( m, N _ S ( r _ S - 1 + x ) ) \\
    B _ S ( m ) & \coloneqq &
      \left (
        \begin{array}{cccc}
          d _ S ( m, 1 ) & d _ S ( m, 2 ) & \cdots & d _ S ( m, X - r _ S ) \\
          p _ S ( m, 1 ) & p _ S ( m, 2 ) & \cdots & p _ S ( m, X - r _ S ) \\
          n _ S ( m, 1 ) & n _ S ( m, 2 ) & \cdots & n _ S ( m, X - r _ S ) \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

新しい行列を求める部分。

{{User:Hexirp/Template:Scroll Top}}

<math>
  e ( S, C, n ) \coloneqq
    \left (
      \begin{array}{cccc|cccc|cccc|cccc|c|cccc}

        S _ { 1, 1 } & S _ { 1, 2 } & \cdots & S _ { 1, R _ S - 1 } &
        { { B' } _ S } _ { ( R _ S - 1 ) + 1 } & { { B' } _ S } _ { ( R _ S - 1 ) + 2 } & \cdots & { { B' } _ S } _ { r _ S - 1 } &
        d _ S ( 1, 1 ) & d _ S ( 1, 2 ) & \cdots & d _ S ( 1, X - r _ S ) &
        d _ S ( 2, 1 ) & d _ S ( 2, 2 ) & \cdots & d _ S ( 2, X - r _ S ) &
        \cdots &
        d _ S ( m, 1 ) & d _ S ( m, 2 ) & \cdots & d _ S ( m, X - r _ S ) \\

        S _ { 2, 1 } & S _ { 2, 2 } & \cdots & S _ { 1, R _ S - 1 } &
        S _ { 2, ( R _ S - 1 ) + 1 } & S _ { 2, ( R _ S - 1 ) + 2 } & \cdots & S _ { 3, r _ S - 1 } &
        p _ S ( 1, 1 ) & p _ S ( 1, 2 ) & \cdots & p _ S ( 1, X - r _ S ) &
        p _ S ( 2, 1 ) & p _ S ( 2, 2 ) & \cdots & p _ S ( 2, X - r _ S ) &
        \cdots &
        p _ S ( m, 1 ) & p _ S ( m, 2 ) & \cdots & p _ S ( m, X - r _ S ) \\

        S _ { 3, 1 } & S _ { 3, 2 } & \cdots & S _ { 1, R _ S - 1 } &
        S _ { 3, ( R _ S - 1 ) + 1 } & S _ { 3, ( R _ S - 1 ) + 2 } & \cdots & S _ { 3, r _ S - 1 } &
        n _ S ( 1, 1 ) & n _ S ( 1, 2 ) & \cdots & n _ S ( 1, X - r _ S ) &
        n _ S ( 2, 1 ) & n _ S ( 2, 2 ) & \cdots & n _ S ( 2, X - r _ S ) &
        \cdots
        & n _ S ( m, 1 ) & n _ S ( m, 2 ) & \cdots & n _ S ( m, X - r _ S ) \\

      \end{array}
    \right )
</math>

{{User:Hexirp/Template:Scroll Bottom}}

怒る親を求める部分。

<math>
  r ( S ) \coloneqq r _ S
</math>

=== 解凍 ===

ここではDPN形式の行列 <math> S </math> から数列 <math> Z </math> へ復元する関数を記述する。

DPN形式の行列の要素へアクセスする関数の部分。

<math>
  \begin{eqnarray*}
    S & \coloneqq &
      \left (
        \begin{array}{cccc}
          S _ { 1, 1 } & S _ { 1, 2 } & \cdots & S _ { 1, X } \\
          S _ { 2, 1 } & S _ { 2, 2 } & \cdots & S _ { 2, X } \\
          S _ { 3, 1 } & S _ { 3, 2 } & \cdots & S _ { 3, X } \\
        \end{array}
      \right ) \\
    D _ S ( x ) & \coloneqq & S _ { 1, x } \\
    P _ S ( x ) & \coloneqq & S _ { 2, x } \\
    N _ S ( x ) & \coloneqq & S _ { 3, x } \\
  \end{eqnarray*}
</math>

DPN形式を山へ解凍する部分。

<math>
  \begin{eqnarray*}
    d _ S ( x, n ) & \coloneqq &
      \begin{cases}
        d _ S ( x, n ^ + ) + d _ S ( p _ S ( x, n ), n ) & ( n < N _ S ( x ) ) \\
        D _ S ( x )                                      & ( n = N _ S ( x ) ) \\
        0                                                & ( n > N _ S ( x ) ) \\
      \end{cases} \\
    p _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( P _ S ( x ), N _ S ( x ) + 1 - n ) & ( n \leq N _ S ( x ) ) \\
        0                                                 & ( n >    N _ S ( x ) ) \\
      \end{cases} \\
    \mathrm{idx} ( p, n ) & \coloneqq &
      \begin{cases}
        p _ a                                          & ( p =              [ p _ a ]                    ) \\
        p _ a                                          & ( p = p _ s \frown [ p _ b, p _ a ] \land n = 1 ) \\
        \mathrm{idx} ( p _ s \frown [ p _ b ], n ^ - ) & ( p = p _ s \frown [ p _ b, p _ a ] \land n > 1 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

展開後の数列。

<math>
  u ( S ) \coloneqq ( d _ S ( 1, 1 ), d _ S ( 2, 1 ), \ldots, d _ S ( X, 1 ) )
</math>

この <math> u ( S ) </math> が <math> Z </math> となる。

=== 全体 ===

<math> S [ n ] </math> を <math> S' </math> へ展開する。

<math>
  \begin{eqnarray*}
    S & = & ( S _ 1, S _ 2, \ldots, S _ X ) \\
    \mathrm{expand} ( S, n ) & \coloneqq & u ( e ( z ( S ), c ( S ), n ) ) \\
  \end{eqnarray*}
</math>

この <math> \mathrm{expand} ( S, n ) </math> は <math> S' </math> である。

=== 性質 ===

期待しているもの。

# <math> u \circ z = \mathrm{id} </math> である。
# 辞書式順序で <math> \forall n, \, \mathrm{expand} ( S, n ) < S </math> である。

=== 参考文献 ===

* [https://docs.google.com/presentation/d/14xksfL9P3A4Vb_-yIY0jdvCvg77MhjUq08LSHrO4iQE/edit?usp=sharing Y数列の解説] - Y数列の基本的な展開はここを参考にしています。
* [https://twitter.com/Y_Y_Googology/status/1165222093857804288 Twitter での質疑応答] - 定義を作る際の助けになりました。
* [[ユーザーブログ:Koteitan/バシク行列の数式的定義]] - 多くの部分はここを元にさせていただきました。
* [[ユーザーブログ:Hexirp/バシク行列を Haskell に移植]] - Ans や ans や nan などが Haskell への移植の際に導入した関数に由来しています。
* [[ユーザーブログ:Hassium108/数列・行列関連]] - リストの結合を <math> \frown </math> で表すのは Hassium108 さんの影響です。

== Y数列 Hexirp 版 1.0 ==

Y数列 Hexirp 版 1.0 は Hexirp 版 0.0 を清書したものである。多くの関数の定義が整理され、様々な間違いが修正された他にも、まだ定義できていないクラス 2 以上に対する展開の部分が取り除かれた。そのため、このバージョンは (1,3) 未満にしか定義されていない（繰り返し展開していくとき）。

このバージョンは、本家が意図するところの理想的なY数列の展開とは明確に違う。例として <math> S = (1,2,4,8,10,8) </math> の展開を見てみる。

; 本家（理想）
: <math> S [ 3 ] = (1,2,4,8,10,7,12,15,11,17,21,16,23,28) </math>
; Hexirp 版 1.0
: <math> S [ 3 ] = (1,2,4,8,10,7,12,14,11,17,19,16,23,25) </math>

この違いはずれるかどうか（上昇するかどうか）の判定方法が理想と異なるためであり、より近づけたものを Hexirp 版 1.1 として公開する予定である。

=== 型 ===

数列は自然数のリストである。DPN形式は D, P, N のタプルのリストである。リストは何らかの列である。リストは添字が 0 から始まるが、特別に数列とDPN形式だけは添字が 1 から始まる。数列は丸括弧とコンマで表され、DPN形式は行列で表され、リストは角括弧とコンマで表される。いずれも基本構造は <math> \_ \cons \_, \nil </math> である。

数列やDPN形式に関係して現れる 0 は何らかの例外を示す。リストに関係して現れる 0 はそうでない。

=== 一般的な表記 ===

ゼロを含まない自然数全体の集合は以下のように表記する。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \mathbb{N} ^ + & = & \{ x \in \mathbb{N} \mid x \neq 0 \} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

再帰により減少および増加していく引数の増減には以下のような表記を使う。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    x ^ - & = & x - 1 \\
    x ^ + & = & x + 1 \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

数列に関する表記は以下のようになる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    X _ S & = & \mathrm{length} ( S ) \\
    S & = & ( S _ 1, S _ 2, \ldots, S _ { X _ S } ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

リストに関する表記は以下のように定義される。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    [ x _ 0, x _ 1, \ldots, x _ n ] & = & x _ 0 \cons x _ 1 \cons \cdots \cons x _ n \cons \nil \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

DPN形式に関する表記は以下のようになる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    X _ Z & = & \mathrm{length} ( Z ) \\
    Z & \coloneqq &
      \left (
        \begin{array}{cccc}
          Z _ { 1, 1 } & Z _ { 1, 2 } & \cdots & Z _ { 1, X _ Z } \\
          Z _ { 2, 1 } & Z _ { 2, 2 } & \cdots & Z _ { 2, X _ Z } \\
          Z _ { 3, 1 } & Z _ { 3, 2 } & \cdots & Z _ { 3, X _ Z } \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

リストに関する汎用関数は以下の通りである。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \mathrm{idx} ( p, n ) & \coloneqq &
      \begin{cases}
        p _ a                                     & ( p = p _ a \cons \nil                          ) \\
        p _ a                                     & ( p = p _ a \cons p _ b \cons p _ s \land n = 0 ) \\
        \mathrm{idx} ( p _ b \cons p _ s, n ^ - ) & ( p = p _ a \cons p _ b \cons p _ s \land n > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

idx (index) はリストの要素へ 0 始まりの添字でアクセスする。だが、要素がもうないときはエラーにならず最後の要素を返す。この関数はもっぱらDPN形式のP、つまり親のリストから全ての深さでの親を復元するために使われる。

=== 数列から山への展開 ===

数列から山への展開は既に完成している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    D _ S ( x, n ) & \coloneqq &
      \begin{cases}
        S _ x                                                    & ( n = 1                              ) \\
        0                                                        & ( n > 1 \land P _ S ( x, n ^ - ) = 0 ) \\
        D _ S ( x, n ^ - ) - D _ S ( P _ S ( x, n ^ - ), n ^ - ) & ( n > 1 \land P _ S ( x, n ^ - ) > 0 ) \\
      \end{cases} \\
    P _ S ( x, n ) & \coloneqq &
      \begin{cases}
        0                                                                                                                          & ( n = 1 \land D _ S ( x, n ) = 1 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \}                                           & ( n = 1 \land D _ S ( x, n ) > 1 ) \\
        0                                                                                                                          & ( n > 1 \land D _ S ( x, n ) = 0 ) \\
        \max \{ p \in \mathbb{N} ^ + \mid p < x \land D _ S ( p, n ) < D _ S ( x, n ) \land p \in \mathrm{Anc} _ S ( x, n ^ - ) \} & ( n > 1 \land D _ S ( x, n ) > 0 ) \\
      \end{cases} \\
    \mathrm{Anc} _ S ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                           & ( x = 0 ) \\
        \{ x \} \cup \mathrm{Anc} _ S ( P _ S ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

D (Diff) は差分を記述し、 P (Parent) はそれらの親を記述する。親を決定する際、バシク行列システムのバージョン 4 と同じように Upper-branch ignoring モデルを使う。その決定に必要になるため Anc (Ancestor) が補助関数として用意されている。

[https://raw.githubusercontent.com/Hexirp/googology/master/v1.0_2.png v1.0_2.png]

=== 山からDPN形式への圧縮 ===

山からDPN形式への圧縮は既に完成している。圧縮の仕方は次の通りである。

第一に、どの深さで展開するか定める。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    T _ S & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid D _ S ( X _ S, n ) > 0 \} \\
    c _ S & \coloneqq & D _ S ( X _ S, T _ S ) \\
    t _ S & \coloneqq &
      \begin{cases}
        T _ S - 1 & ( c _ S = 1 ) \\
        T _ S     & ( c _ S > 1 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

T はカットする部分の中で最も深いゼロではない要素の深さである。 c は T の要素の値であり、これが数列のクラスである。 t は展開する深さである。ここで c が 1 だと T - 1 になるが、それ以外ではそのままである。ここは (1,2,4,8) などを展開しようとするときに深さを 1 つ減らさないとできなかったため、こうなった。このような定義が必要なのは横へ展開するか斜めへ展開するかの違いが原因だと私は見ている。

第二に、どこからどこまで親のデータを保存するか決める。さっきもちらっと触れたが、「親が変化し始めてから最大の深さに到達するまでの親」が範囲である。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    m            _ S ( x ) & \coloneqq & \min ( n _ S ( x ), u _ S ( x ) ) \\
    u            _ S ( x ) & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid P _ S ( x, 1 ) = P _ S ( x, n ) \land n \le \mathrm{btm} _ S  ( x ) \} \\
    \mathrm{btm} _ S ( x ) & \coloneqq & \max \{ n \in \mathbb{N} ^ + \mid D _ S ( x, n ) > 0 \} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

ここで最大の深さとは n である。 u は親が変化し始めた箇所である。補助関数として親が存在する最も深い深さを返す btm が用意されている。

第三に、DPN形式を構築する。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    d _ S ( x ) & \coloneqq & D _ S ( x, n _ S ( x ) ) \\
    p _ S ( x ) & \coloneqq & \mathrm{map} ( \lambda v \ldotp P _ S ( x, v ), \mathrm{enumFromTo} ( m _ S ( x ), n _ S ( x ) ) ) \\
    n _ S ( x ) & \coloneqq & \min ( t _ S, \mathrm{btm} _ S ( x ) ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

ここで n は一番下に書かれているくせに他の個所から使われているので注意である。その意味は、さっきも書いた通り「最大の深さ」である。どのくらい深く潜れるか (btm) と展開の深さ (t) を合わせて決定する。 d ( x ) は n での D である。 p は m から n までの P のリストである。

ここで、深さを返す大量の関数 (T, t, btm, n, u, m) が出てくるためわかりづらいかもしれない。色がごちゃごちゃしてしまったためわかりづらくなってしまったが、理解の一助になればと図を描いた。

[https://raw.githubusercontent.com/Hexirp/googology/master/v1.0_1.png v1.0_1.png]

=== DPN形式の展開 ===

DPN形式の展開はクラス 1 に対するものだけ完成している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    d _ Z ( x ) & \coloneqq & Z _ { 1, x } \\
    p _ Z ( x ) & \coloneqq & Z _ { 2, x } \\
    n _ Z ( x ) & \coloneqq & Z _ { 3, x } \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

d, p, n はそれぞれ対応する要素へのアクセス関数である。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    R _ Z & \coloneqq & \mathrm{last} ( p _ Z ( X _ Z ) ) \\
    G _ Z & \coloneqq &
      \left (
        \begin{array}{cccc}
          Z _ { 1, 1 } & Z _ { 1, 2 } & \cdots & Z _ { 1, R _ Z - 1 } \\
          Z _ { 2, 1 } & Z _ { 2, 2 } & \cdots & Z _ { 2, R _ Z - 1 } \\
          Z _ { 3, 1 } & Z _ { 3, 2 } & \cdots & Z _ { 3, R _ Z - 1 } \\
        \end{array}
      \right ) \\
    B _ Z & \coloneqq &
      \left (
        \begin{array}{cccc}
          Z _ { 1, R _ Z - 1 + 1 } & Z _ { 1, R _ Z - 1 + 2 } & \cdots & Z _ { 1, X _ Z - 1 } \\
          Z _ { 2, R _ Z - 1 + 1 } & Z _ { 2, R _ Z - 1 + 2 } & \cdots & Z _ { 2, X _ Z - 1 } \\
          Z _ { 3, R _ Z - 1 + 1 } & Z _ { 3, R _ Z - 1 + 2 } & \cdots & Z _ { 3, X _ Z - 1 } \\
        \end{array}
      \right ) \\
    C _ Z & \coloneqq &
      \left (
        \begin{array}{c}
          Z _ { 1, X _ Z } \\
          Z _ { 2, X _ Z } \\
          Z _ { 3, X _ Z } \\
        \end{array}
      \right ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

R は分割する位置、 G は良い部分、 B は悪い部分、 C は切り落とされる要素である。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \mathrm{pnt} _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( \mathrm{reverse} ( p _ Z ( x ) ), n _ Z ( x ) - n ) & ( n \leq n _ Z ( x ) ) \\
        0                                                                  & ( n >    n _ Z ( x ) ) \\
      \end{cases} \\
    \mathrm{anc} _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        \emptyset                                                      & ( x = 0 ) \\
        \{ x \} \cup \mathrm{anc} _ Z ( \mathrm{pnt} _ Z ( x, n ), n ) & ( x > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

pnt (parent) は親の情報を全て復元する。そのデータを使って anc (ancestor) は祖先を計算する。

ここで本来であればクラスによる分岐がある。この分岐に跨る関数が二つあり、それは r と e である。しかしながら、ここではクラス 1 だけ取り扱うため分岐がなくなっている。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    r _ Z & \coloneqq & R _ Z \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

R が D への bad root だとしたら r は P と N への bad root である。この値は P と N がコピーされる範囲を決めるが、それよりも重要なのが、展開された後のDPN形式の行列の長さ <math> X _ { Z [ n ] } </math> は <math> X _ Z - 1 + r \times n </math> に等しいということである。この性質は、クラス n での定義で重要になる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \delta _ Z & \coloneqq & X _ Z - r _ Z \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

δ はコピーされる部分の長さであり、主に親を参照するインデックスがどれだけずれるかを決める。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    a _ Z ( y, n ) & \coloneqq &
      \begin{cases}
        1 & ( r _ Z \in    \mathrm{anc} _ Z ( r _ Z - 1 + y, n ) ) \\
        0 & ( r _ Z \notin \mathrm{anc} _ Z ( r _ Z - 1 + y, n ) ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

位置 y と深さ n を取って親がずれるかどうかを決める。もし、先祖を辿って行って bad root に行き着くならば一緒にずれる。そうでないならば、ずれない。ここで位置に y を使っているのは bad part の内部の位置であるため。全体の位置なら x になる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \mathrm{bas} _ Z ( y ) & \coloneqq &
      \begin{cases}
        p _ Z ( X _ Z )         & ( y = 1 ) \\
        p _ Z ( r _ Z - 1 + y ) & ( y > 1 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

bas (base) はコピーされた bad part の基本の親を決める。これが必要なのは接ぎ木があるからである。元の bad part とは違って、コピーされた bad part は一番最初の要素の親がカットされた要素の親になる。カットされた部分に接ぎ木するイメージである。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    \mathrm{rising} _ Z ( m, y, p, n ) & \coloneqq & p + m \times \delta _ Z \times a _ Z ( y, n ) \\
    \mathrm{rise} _ Z ( m, y, p, n ) & \coloneqq &
      \begin{cases}
        ( \nil, n )                                                  & ( p = \nil                                                                      ) \\
        ( \mathrm{rising} _ Z ( m, y, p _ v, n' ) \cons p', n' - 1 ) & ( p = p _ v \cons p _ s \land ( p', n' ) = \mathrm{rise} _ Z ( m, y, p _ s, n ) ) \\
      \end{cases} \\
    \mathrm{ris} _ Z ( m, y, p, n ) & \coloneqq & p' \quad ( ( p', \_ ) = \mathrm{rise} _ Z ( m, y, p, n ) ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

ris (rising) は親をずらしていく部分。引数の m はコピーされた行列の中で 1 始まりで何番目か、 y はコピーされた行列で 1 始まりで何番目か、 p は親のデータ群、 n は深さである。

rise の定義は最難関かもしれない。継続っぽい手法を使ってリストの構造と逆向きの再帰 (foldl) を順向きの再帰 (foldr) に変換している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    b _ Z ( m, y ) & \coloneqq & d _ Z ( r _ Z - 1 + y ) \\
    q _ Z ( m, y ) & \coloneqq &
      \begin{cases}
        \mathrm{ris} _ Z ( m - 1, y, \mathrm{bas} _ Z ( y ), n _ Z ( r _ Z - 1 + y ) ) & ( y = 1 ) \\
        \mathrm{ris} _ Z ( m, y, \mathrm{bas} _ Z ( y ), n _ Z ( r _ Z - 1 + y ) )     & ( y > 1 ) \\
      \end{cases} \\
    m _ Z ( m, y ) & \coloneqq & n _ Z ( r _ Z - 1 + y ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

b, q は普通のコピペ。 q は bas で接ぎ木している関係上、先頭のところだけ m が一つずれる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    B _ Z ( m ) & \coloneqq &
      \begin{cases}
        B _ Z                                                                                                                       & ( c = 0 ) \\
        \mathrm{map} ( \lambda y \ldotp ( b _ Z ( m, y ), q _ Z ( m, y ), m _ Z ( m, y ) ), \mathrm{enumFromTo} ( 1, \delta _ Z ) ) & ( c > 0 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

B は、コピーされた悪い部分である。

最終的に、全体の展開は以下のようになる。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    Z' & \coloneqq &
      \begin{cases}
        G _ Z \append \mathrm{concat} ( \mathrm{map} ( \lambda m \ldotp B _ Z ( m ), \mathrm{enumFromTo} ( 0, n ) ) & ( c = 1 ) \\
        \mathrm{undefined}                                                                                          & ( c > 1 ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

=== DPN形式から山への解凍 ===

DPN形式から山への解凍は既に完成している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    d _ Z ( x ) & \coloneqq & Z _ { 1, x } \\
    p _ Z ( x ) & \coloneqq & Z _ { 2, x } \\
    n _ Z ( x ) & \coloneqq & Z _ { 3, x } \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

d, p, n はそれぞれ対応する要素へのアクセス関数である。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    D _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        P _ Z ( x, n ^ + ) + D _ Z ( P _ Z ( x, n ), n ) & ( n < N _ Z ( x ) ) \\
        d _ Z ( x )                                      & ( n = N _ Z ( x ) ) \\
        0                                                & ( n > N _ Z ( x ) ) \\
      \end{cases} \\
    P _ Z ( x, n ) & \coloneqq &
      \begin{cases}
        \mathrm{idx} ( \mathrm{reverse} ( d _ Z ( x ) ), n _ Z ( x ) - n ) & ( n \leq N _ Z ( x ) ) \\
        0                                                                  & ( n >    N _ Z ( x ) ) \\
      \end{cases} \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

D, P は言わずもがな山を作る関数である。

=== 山から数列への変換 ===

山から数列への変換は既に完成している。

{{User:Hexirp/Template:Scroll Top}}

<math>
  \begin{eqnarray*}
    S & \coloneqq & \mathrm{map} ( \lambda x \ldotp D _ Z ( x, 1 ), \mathrm{enumFromTo} ( 1, X _ Z ) ) \\
  \end{eqnarray*}
</math>

{{User:Hexirp/Template:Scroll Bottom}}

== 脚注 ==

<references/>
