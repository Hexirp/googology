{{tocright}}

== 要旨 ==

この記事では、超限ハイパー演算子の定義について考察する。ただ大きさを求めて作るだけなら他の表記を使えばよいだけなので、ハイパー演算子の形を保ったまま、最も美しい定義を追い求める。その帰結として、有限の範囲において通常のハイパー演算子と完全に一致し、順序数の範囲においては、 \( 1 \) 段と \( 2 \) 段と \( 3 \) 段の演算が加算と乗算と冪乗を完全に再現し、テトレーションを超えても破綻せず、 \( \omega \) 階を超えても破綻せず、 \( \omega \mathbin{ [ \omega ] } \omega \) が \( \varphi _ \omega ( 0 ) \) となり、その表記としての限界が \( \Gamma _ 0 \) であり、それでいてハイパー演算子の形を保ち、それらに加えて、その定義が一貫していて美しいような超限ハイパー演算子の定義を示す。

== 序論 ==

超限ハイパー演算子は、ハイパー演算子を超限順序数へ拡張するという単純な発想の表記であり、様々な巨大数研究者が作成している表記でもある。

しかしながら、本来のハイパー演算子の形を保ったまま \( \varepsilon _ 0 \) を超えることができた超限ハイパー演算子は、これまでに存在しない。このような表記は、長い間、不在であり続けていた。

その理由は、加算と乗算と冪乗は超限順序数へ拡張することが容易であるのに対して、テトレーションでは単純に拡張すると \( \omega \uparrow \uparrow \omega = \varepsilon _ 0 \) が成立し \( \omega \uparrow \uparrow ( \omega + 1 ) = \omega ^ { \omega \uparrow \uparrow \omega } = \omega ^ { \varepsilon _ 0 } = \varepsilon _ 0 \) となることから、 \( \xi \mapsto \omega \uparrow \uparrow \xi \) の上限が \( \varepsilon _ 0 \) となるという不都合な現象が発生するためである。

これは、ハイパー演算子は単調増加であるべきという点で問題であるが、超限ハイパー演算子というコンセプトが有する本来のポテンシャルを発揮できていないという点でも問題である。

大多数の巨大数研究者が \( \omega \mathbin{ [ \omega ] } \omega = \varphi _ \omega ( 0 ) \) となり \( \xi \mapsto \omega \mathbin{ [ \xi ] } \omega \) で閉じている最小の順序数が \( \Gamma _ 0 \) となるのが自然なのではないかと考えており、これに届かないという点で問題なのである。

これを裏付ける状況証拠として、緩増加関数を解析した結果を例に挙げることができる。 \( g _ \alpha ( x ) \) が \( \alpha \) の中の \( \omega \) を \( x \) に置き換えた値と、概ね一致するという経験則がある。それに加えて \( g _ { \varphi _ \omega ( 0 ) } ( n ) \approx n \mathbin{ [ n ] } n \) であり \( g _ { \varphi _ \alpha ( 0 ) } ( n ) \approx n \mathbin{ [  g _ \alpha ( n ) ] } n \) である。このことから、前述の予想を立てることができるのである。

超限ハイパー演算子というコンセプトが有する本来のポテンシャルを発揮するために、様々な巨大数研究者がハイパー演算子の形を崩した表記を作成してきた。たとえば、 "[[:en:User_blog:EricABQ/Formal_definition_of_ordinal_hyper-operators_using_the_climbing_method|Formal definition of ordinal hyper-operators using the climbing method]]" (EricABQ) では Jonathan Bowers が BEAF のために開発した climbing method をハイパー演算子へと転用している。かくいう私も『[[ユーザーブログ:Hexirp/ハイパー演算子の拡張|ハイパー演算子の拡張]]』で上付きハイパー演算子ではなく下付きハイパー演算子を超限順序数へ拡張すると \( \varepsilon _ 0 \) を超えて増大することを指摘している。

この記事では、有限の範囲において通常のハイパー演算子と完全に一致し、順序数の範囲においては、 \( 1 \) 段と \( 2 \) 段と \( 3 \) 段の演算が加算と乗算と冪乗を完全に再現し、テトレーションを超えても破綻せず、 \( \omega \) 階を超えても破綻せず、 \( \omega \mathbin{ [ \omega ] } \omega \) が \( \varphi _ \omega ( 0 ) \) となり、その表記としての限界が \( \Gamma _ 0 \) であり、それでいてハイパー演算子の形を保ち、それらに加えて、その定義が一貫していて美しいような超限ハイパー演算子の定義を示す。

== ハイパー演算子 ==

ハイパー演算子とは、加算を繰り返して乗算を定義し、乗算を繰り返して冪乗を定義するという流れを、さらに繰り返した演算子である。つまり、冪乗を繰り返すことによりテトレーションを定義し、テトレーションを繰り返すことによりペンテーションを定義するように続けていくのである。

加算を一番目のハイパー演算子であるとし、乗算を二番目のハイパー演算子であるとし、冪乗を三番目のハイパー演算子であるとし、これを続けていくと、一般に \( n \) 番目のハイパー演算子という概念について考察することができよう。

\( n \) 番目のハイパー演算子を表記するためには、色々な方法があるが、この記事では、新しく \( a \mathbin{ [ n ] } x \) と表記することにする。角括弧を使うのは、 LaTeX において一文字だけで入力できる括弧の種類が丸括弧と角括弧だけであり、丸括弧は他の用途が多く重複しやすいため、角括弧を採用したからである。

\( a \mathbin{ [ n ] } x \) と書くとき、 \( a \) を基数と呼び、 \( x \) を指数と呼び、 \( n \) を階数と呼ぶことにする。英語版ウィキペディアの "[https://en.wikipedia.org/w/index.php?title=Hyperoperation&oldid=1110399282 Hyperoperation]" にあった用語法を参考にして、「基数」は "base" の訳として、「指数」は "exponent" の訳として、「階数」は "rank" の訳として、それぞれ充てた。

ハイパー演算子の素朴な定義は、次の通りである。ただし、 \( a \geq 1 \) かつ \( n \geq 1 \) かつ \( x \geq 1 \) であるとする。つまり、基数と指数と階数が正の自然数であるということである。

<nowiki>\[
  a \mathbin{ [ n ] } x
    =
      \begin{cases}
        a + x & ( n = 1 ) \\
        a \times x & ( n = 2 ) \\
        a ^ x & ( n = 3 ) \\
        \underbrace{ a \mathbin{ [ n - 1 ] } ( \cdots a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n - 1 ] } a ) ) \cdots ) } _ \textrm{\( b \) ko no \( a \) ga aru} & ( n \geq 4 ) \\
      \end{cases}
\]</nowiki>

ここで、 \( \textrm{\( b \) ko no \( a \) ga aru} \) という点々を使った省略表記は、その解釈が曖昧になる余地がある。もちろん、この場合では問題にならないだろうが、定義の考察をするにあたり障害となることも確かである。

そこで、 \( a \) を並べる部分を省略せずに表記すると、次のように定義することになる。ここで、 \( \langle n , x \rangle \) が \( \mathbb{N} \times \mathbb{N} \) の辞書式順序について減少しているため、この定義は整合的である。

<nowiki>\[
  a \mathbin{ [ n ] } x
    =
      \begin{cases}
        a + x & ( n = 1 ) \\
        a \times x & ( n = 2 ) \\
        a ^ x & ( n = 3 ) \\
        a & ( n \geq 4 \wedge x = 1 ) \\
        a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } ( x - 1 ) ) & ( n \geq 4 \wedge x \geq 2 ) \\
      \end{cases}
\]</nowiki>

ハイパー演算子の素朴な定義では基数と指数と階数が正の自然数でなければならず、これは順序数へ拡張する場合においては問題にならないが、この記事では美しさも追及するため、ゼロの場合においても定義できるように拡張する。

== ゼロの場合について ==

前の節ではハイパー演算子の素朴な定義を示したが、これを通常の自然数まで拡張することを考察する。

=== 基数がゼロである場合について ===

基数がゼロである場合について、つまり \( a \) がゼロである場合について考察しよう。

もとより \( a \) についての場合分けは全く行っておらず、そのまま \( a \) へゼロを代入するだけでよい。

=== 指数がゼロである場合について ===

指数がゼロである場合について、つまり \( x \) がゼロである場合について考察しよう。

ここで、階数について場合分けしてから指数について場合分けしているため、階数について場合分けしてから、それぞれの場合において指数がゼロである場合について考察する。

\( n = 1 \) である場合については、 \( a \mathbin{ [ n ] } x = a + x \) であることから、ここの \( x \) へ \( 0 \) を仮に代入することで、 \( a \mathbin{ [ 1 ] } 0 = a \) を得ることができる。

\( n = 2 \) である場合については、 \(  a \mathbin{ [ n ] } x = a \times x \) であることから、ここの \( x \) へ \( 0 \) を仮に代入することで、 \( a \mathbin{ [ 2 ] } 0 = 0 \) を得ることができる。

\( n = 3 \) である場合については、 \(  a \mathbin{ [ n ] } x = a ^ x \) であることから、ここの \( x \) へ \( 0 \) を仮に代入することで、 \( a \mathbin{ [ 3 ] } 0 = 1 \) を得ることができる。

ここで注意しなければならないのは、 \( a \) がゼロである場合において \( 0 ^ 0 \) が現れることであり、実数の冪乗では \( 0 ^ 0 \) は未定義であるが、自然数の冪乗では \( 0 ^ 0 \) は \( 1 \) であるため、常に \( a ^ 0 = 1 \) が成立し、問題ないことになる。

\( n \geq 4 \) である場合については、少し複雑である。 \( a \mathbin{ [ n ] } 0 \) が満たすべき条件へ注目する。

\( a \mathbin{ [ n ] } x = a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } ( x - 1 ) ) \) であることから、ここの \( x \) に \( 1 \) を仮に代入することで、 \( a \mathbin{ [ n ] } 1 = a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } 0 ) \) であると、仮に考える。

\( n \geq 2 \) について \( a \mathbin{ [ n ] } 1 = a \) であることから、 \( n \geq 4 \) について \( a \mathbin{ [ n ] } 1 = a \) かつ \( a \mathbin{ [ n - 1 ] } 1 = a \) である。

\( a \mathbin{ [ n ] } 1 = a \) かつ \( a \mathbin{ [ n - 1 ] } 1 = a \) かつ \( a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } 0 ) = a \mathbin{ [ n ] } 1 \) であることから、 \( a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } 0 ) = a \) であり、 \( a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } 0 ) = a \mathbin{ [ n - 1 ] } 1 \) であると、仮に考える。

\( x \mapsto a \mathbin{ [ n - 1 ] } x \) は単調増加関数であると仮に考えると、 \( a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } 0 ) = a \mathbin{ [ n - 1 ] } 1 \) から \( a \mathbin{ [ n ] } 0 = 1 \) を得ることができる。

=== 階数がゼロである場合について ===

階数がゼロである場合について、つまり \( n \) がゼロである場合について考察しよう。これも \( a \mathbin{ [ 0 ] } b \) が満たすべき条件へ注目する。

\( a \mathbin{ [ n ] } x = a \mathbin{ [ n - 1 ] } ( a \mathbin{ [ n ] } ( x - 1 ) ) \) であることから、ここの \( a \) に \( 1 \) を仮に代入することで、 \( a \mathbin{ [ 1 ] } x = a \mathbin{ [ 0 ] } ( a \mathbin{ [ 1 ] } ( x - 1 ) ) \) であると、仮に考える。

\( a \mathbin{ [ 1 ] } x = a + x \) であると仮に考えると、 \( x \geq 1 \) について \( a + x = a \mathbin{ [ 0 ] } ( a + ( x - 1 ) ) \) であるということになり、これを満たす関数を考えることにする。

\( a + x = a \mathbin{ [ 0 ] } ( a + ( x - 1 ) ) \) であるような関数は無数にあり、もっとも単純な解として \( a \mathbin{ [ 0 ] } x = x + 1 \) がある。これは英語版ウィキペディアの "[https://en.wikipedia.org/w/index.php?title=Hyperoperation&oldid=1110399282 Hyperoperation]" と同じ定義となる。

\( a \mathbin{ [ 0 ] } x = x + 1 \) と定義することは、後者関数から全てを構築するというコンセプトにおいては美しいが、 \( a \) の値を捨てており、可換性を持たないという欠点もある。

<p style="display: none;"><nowiki>\(
  \newcommand{\p}[1]{ \mathord{ \left( #1 \right) } }
  \newcommand{\b}[1]{ \mathord{ \left[ #1 \right] } }
  \newcommand{\c}[1]{ \mathord{ \left\{ #1 \right\} } }
  \newcommand{\a}[1]{ \mathord{ \left\langle #1 \right\rangle } }
  \newcommand{\bo}[1]{ \mathbin{ \left[ #1 \right] } }
\)</nowiki></p>

== ゼロへの拡張 ==

三番目に、 \( n = 0 \) の場合を考えよう。 \( a \bo{ n + 1 } \p{ b + 1 } = a \bo{ n } \p{ a \bo{ n + 1 } b } \) に \( n = 0 \) を仮想的に代入して、 \( a \bo{ 0 + 1 } \p{ b + 1 } = a \bo{ 0 } \p{ a \bo{ 0 + 1 } b } \) となる。このため、 \( a + \p{ b + 1 } = a \bo{ 0 } \p{ a + b } \) ということになる。その最も単純な解は \( a \bo{ 0 } b = b + 1 \) とすることであろう。しかし、これには対称でないという欠点がある。そのため、左右対称とするために \( a \bo{ 0 } b = \mathrm{max} \p{ a, b } + 1 \) とする。

同時に \( a \bo{ 1 } 0 \) の値を定めなければならない。これは \( a \) と \( 0 \) の二択であるが、 \( a \bo{ 0 } b = b + 1 \) である時の値に合わせて \( a \) とする。

これらを纏めると、次のようになる。

<nowiki>\[
  \begin{align}
    a \bo{ 0 } 0 & = a + 1 \\
    a \bo{ 1 } 0 & = a \\
    a \bo{ 2 } 0 & = 0 \\
    a \bo{ n } 0 & = 1 & & \p{ 3 \leq n } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a, b } + 1 \\
    a \bo{ n } b & = a \bo{ n' } \p{ a \bo{ n } b' } & & \p{ 1 \leq n \wedge 1 \leq b \wedge n' + 1 = n \wedge b' + 1 = b } \\
  \end{align}
\]</nowiki>

== 順序数への拡張 ==

さて、このハイパー演算子は簡単に順序数へ拡張することが出来る。超限帰納法を使えば良いのだ。

\( \mathrm{p} \p{ \alpha } = \min \c{ \beta \in \mathrm{On} : \forall \p{ \gamma \in \mathrm{On} } \ldotp \gamma < \alpha \to \gamma \leq \beta } \) を補助関数として定義する。

<nowiki>\[
  \begin{align}
    a \bo{ 0 } 0 & = a + 1 \\
    a \bo{ 1 } 0 & = a \\
    a \bo{ 2 } 0 & = 0 \\
    a \bo{ n } 0 & = 1 & & \p{ 3 \leq n } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a, b } + 1 & & \p{ \textrm{\( b \) is successor} } \\
    a \bo{ n } b & = a \bo{ \mathrm{p} \p{ n } } \p{ a \bo{ n } \mathrm{p} \p{ b } } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is successor} } \\
    a \bo{ n } b & = \sup_{ n' < n } \p{ a \bo{ n' } b } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is limit} } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a , b } + 1 & & \p{ \textrm{\( b \) is limit} } \\
    a \bo{ n } b & = \sup_{ b' < b } \p{ a \bo{ n } b' } & & \p{ \textrm{\( b \) is limit} } \\
  \end{align}
\]</nowiki>

この演算子の値は次のようになる。

* \( \omega \bo{ 0 } \omega = \omega + 1 \)
* \( \omega \bo{ 0 } \p{ \omega + 1 } = \omega + 2 \)
* \( \omega \bo{ 1 } \omega = \omega + \omega \)
* \( \omega \bo{ 1 } \p{ \omega + 1 } = \omega \bo{ 0 } \p{ \omega \bo{ 1 } \omega } = \omega + \omega + 1 \)
* \( \omega \bo{ 2 } \omega = \omega^2 \)
* \( \omega \bo{ 2 } \p{ \omega + 1 } = \omega \bo{ 1 } \p{ \omega \bo{ 2 } \omega } = \omega \bo{ 1 } \omega^2 = \omega^2 \)
* \( \omega \bo{ 3 } \omega = \omega^2 \)
* \( \omega \bo{ 3 } \p{ \omega + 1 } = \omega \bo{ 2 } \p{ \omega \bo{ 3 } \omega } = \omega \bo{ 2 } \omega^2 = \omega^2 \)

\( \omega^2 \) を超えて大きくならない。これは大問題である。一つ目に、ハイパー演算子の本来の意味によると、 \( a \bo{ 2 } b \) は \( a \times b \) は同値であるべきなのだが、これが成り立たない。二つ目に、 \( \omega^2 \) が限界というのはあまりにも小さすぎる。三つ目に、 \( \p{ \omega \bo{ 2 } \omega } \bo{ 1 } \omega \) とすれば \( \omega^2 + \omega \) になるため、まだ大きくなれる余地があるのに、それを発揮できていない。

どうやって、この問題を回避すればよいのだろうか？　\( \omega \bo{ 2 } \p{ \omega + 1 } \) の結果を \( \omega \bo{ 1 } \p{ \omega \bo{ 2 } \omega } \) から \( \p{ \omega \bo{ 2 } \omega } \bo{ 1 } \omega \) にすれば私が望む結果となることに注目したい。この後者は下付きハイパー演算子の定義である。

上記の定義の再帰を下付きハイパー演算子のものにすればよいのだろうか？　いや、そうすると、別の問題が出てくる。一つ目に、私が定義したいのは通常のハイパー演算子である。二つ目に、下付きハイパー演算子は \( 0 \) へ拡張することが出来ない。

ならば、別の方法が必要である。ここで \( \omega \bo{ 1 } \p{ \omega \bo{ 2 } \omega } < \p{ \omega \bo{ 2 } \omega } \bo{ 1 } \omega \) になっていることに注目しよう。すると、 \( a \bo{ n + 1 } \p{ b + 1 } \) の定義として、普通は \( a \bo{ \mathrm{p} \p{ n } } \p{ a \bo{ n } \mathrm{p} \p{ b } } \) とし、それよりも \( \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ \mathrm{p} \p{ n } } a \) の方が大きい時に、それを選ぶというものを考えることが出来る。

これを単純に表すと、 \( \max \p{ a \bo{ \mathrm{p} \p{ n } } \p{ a \bo{ n } \mathrm{p} \p{ b } }, \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ \mathrm{p} \p{ n } } a } \) である。さて、この定義には問題はないのだろうか。なんと問題ないのである。有限の範囲において値が変わることはない。

さて、この定義は意図せずに \( a \bo{ 0 } b = \max \p{ a, b } + 1 \) と形式が似ている。更に形式を似せた方が美しくなるので、 \( \max \p{ a + 1, b + 1 } \) という風にそろえることにする。

これを纏めると次のようになる。

<nowiki>\[
  \begin{align}
    a \bo{ 0 } 0 & = a + 1 \\
    a \bo{ 1 } 0 & = a \\
    a \bo{ 2 } 0 & = 0 \\
    a \bo{ n } 0 & = 1 & & \p{ 3 \leq n } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a + 1, b + 1 } & & \p{ \textrm{\( b \) is successor} } \\
    a \bo{ n } b & = \mathrm{max} \p{ a \bo{ \mathrm{p} \p{ n } } \p{ a \bo{ n } \mathrm{p} \p{ b } }, \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ \mathrm{p} \p{ n } } a } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is successor} } \\
    a \bo{ n } b & = \sup_{ n' < n } \p{ a \bo{ n' } b } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is limit} } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a + 1, b + 1 } & & \p{ \textrm{\( b \) is limit} } \\
    a \bo{ n } b & = \sup_{ b' < b } \p{ a \bo{ n } b' } & & \p{ \textrm{\( b \) is limit} } \\
  \end{align}
\]</nowiki>

この演算子の値は次のようになる。

* \( \omega \bo{ 2 } \p{ \omega + 1 } = \p{ \omega \bo{ 2 } \omega } \bo{ 1 } \omega = \omega^2 \bo{ 1 } \omega = \omega^2 + \omega \)
* \( \omega \bo{ 2 } \p{ \omega + \omega } = \omega^2 + \omega^2 \)
* \( \omega \bo{ 2 } \p{ \omega \bo{ 2 } \omega } = \omega^3 \)
* \( \omega \bo{ 3 } \omega = \omega^\omega \)
* \( \omega \bo{ 3 } \p{ \omega + 1 } = \p{ \omega \bo{ 3 } \omega } \bo{ 2 } \omega = \omega^{ \omega + 1 } \)
* \( \omega \bo{ 3 } \p{ \omega \bo{ 3 } \omega } = \omega^{ \omega^\omega } \)
* \( \omega \bo{ 4 } \omega = \varepsilon_0 \)
* \( \omega \bo{ 4 } \p{ \omega + 1 } = \p{ \omega \bo{ 4 } \omega } \bo{ 3 } \omega = \omega^{ \omega^{ \varepsilon_0 + 1 } } \)
* \( \omega \bo{ 4 } \p{ \omega + 2 } = \omega \bo{ 3 } \p{ \omega \bo{ 4 } \p{ \omega + 1 } } = \omega^{ \omega^{ \omega^{ \varepsilon_0 + 1 } } } \)
* \( \omega \bo{ 4 } \p{ \omega + \omega } = \varepsilon_1 \)
* \( \omega \bo{ 4 } \omega^2 = \varepsilon_\omega \)
* \( \omega \bo{ 4 } \omega^\omega = \varepsilon_{ \omega^\omega } \)
* \( \omega \bo{ 4 } \p{ \omega \bo{ 4 } \omega } = \varepsilon_{ \varepsilon_0 } \)
* \( \omega \bo{ 5 } \omega = \zeta_0 \)
* \( \omega \bo{ 5 } \p{ \omega + 1 } = \p{ \omega \bo{ 5 } \omega } \bo{ 4 } \omega = \varepsilon_{ \zeta_0 + 1 } \)
* \( \omega \bo{ 5 } \p{ \omega + 2 } = \omega \bo{ 4 } \p{ \omega \bo{ 5 } \p{ \omega + 1 } } = \varepsilon_{ \varepsilon_{ \zeta_0 + 1 } } \)
* \( \omega \bo{ 5 } \p{ \omega + \omega } = \zeta_1 \)
* \( \omega \bo{ 6 } \omega = \varphi_3 \p{ 0 } \)
* \( \omega \bo{ \omega } \omega = \varphi_\omega \p{ 0 } \)
* \( \omega \bo{ \omega } \p{ \omega + 1 } = \sup_{ n < \omega } \p{ \omega \bo{ n } \p{ \omega + 1 } } = \varphi_\omega \p{ 0 } \)
* \( \p{ \omega \bo{ \omega } \omega } \bo{ \omega } \omega = \varphi_\omega \p{ 1 } \)
* \( \p{ \p{ \omega \bo{ \omega } \omega } \bo{ \omega } \omega } \bo{ \omega } \omega = \varphi_\omega \p{ 2 } \)
* \( \omega \bo{ \omega + 1 } \omega = \varphi_\omega \p{ \omega } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega + 1 } = \p{ \omega \bo{ \omega + 1 } \omega } \bo{ \omega } \omega = \varphi_\omega \p{ \omega + 1 } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega + 2 } = \p{ \p{ \omega \bo{ \omega + 1 } \omega } \bo{ \omega } \omega } \bo{ \omega } \omega = \varphi_\omega \p{ \omega + 2 } \)

またもや \( \omega \bo{ \omega } \omega \) と \( \omega \bo{ \omega } \p{ \omega + 1 } \) の値が等しくなってしまうという現象が起こった。 \( \omega \bo{ 2 } \omega \) と \( \omega \bo{ 2 } \p{ \omega + 1 } \) が等しくなった時は、そこで増加が止まったわけだから、これはだいぶ悪いサインである。

しかし、今回は \( \omega \bo{ \omega } \p{ \omega \bo{ \omega } \omega } \) で再び大きくなりはする。だが、途中で増加が止まるというのは悪いサインなので、これは改善したい。

この現象が起こるのは何故だろうか？　それは \( \textrm{\( b \) is successor} \wedge \textrm{\( n \) is limit} \) の時の定義がよくないからである。たとえるなら、 \( \varphi_\omega \p{ 1 } \) の定義を \( \sup_{ n < \omega } \varphi_n \p{ \varphi_\omega \p{ 0 } + 1 } \) ではなく \( \sup_{ n < \omega } \varphi_n \p{ 1 } \) としてしまっているような、そんな感じである。ならば、その解決策も、ヴェブレン表記を参考にすればよい。

\( \omega \bo{ \omega } \p{ \omega + 1 } \) の値は、有限の時と同じように \( \omega \bo{ \omega } \p{ \omega } \) に \( \omega \bo{ n } \_ \) を適用する形になるはずだが、 \( n \) の部分をハイパー演算子と同じように 1 つ小さい値にすることが出来ないため、それを断念したという形である。しかし、ヴェブレン表記を参考にするともう一つの道が見えてくる。 \( \sup_{ n' < n } \mathrm{max} \p{ a \bo{ n' } \p{ a \bo{ n } \mathrm{p} \p{ b } }, \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ n' } a } \) とすれば良いのだ。これも形式を同じにするために \( \mathrm{max} \p{ \sup_{ n' < n } \p{ a \bo{ n' } \p{ a \bo{ n } \mathrm{p} \p{ b } } }, \sup_{ n' < n } \p{ \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ n' } a } } \) としよう。

これを纏めると次のようになる。

<nowiki>\[
  \begin{align}
    a \bo{ 0 } 0 & = a + 1 \\
    a \bo{ 1 } 0 & = a \\
    a \bo{ 2 } 0 & = 0 \\
    a \bo{ n } 0 & = 1 & & \p{ 3 \leq n } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a + 1, b + 1 } & & \p{ \textrm{\( b \) is successor} } \\
    a \bo{ n } b & = \mathrm{max} \p{ a \bo{ \mathrm{p} \p{ n } } \p{ a \bo{ n } \mathrm{p} \p{ b } }, \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ \mathrm{p} \p{ n } } a } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is successor} } \\
    a \bo{ n } b & = \mathrm{max} \p{ \sup_{ n' < n } \p{ a \bo{ n' } \p{ a \bo{ n } \mathrm{p} \p{ b } } }, \sup_{ n' < n } \p{ \p{ a \bo{ n } \mathrm{p} \p{ b } } \bo{ n' } a } } & & \p{ \textrm{\( b \) is successor} \wedge \textrm{\( n \) is limit} } \\
    a \bo{ 0 } b & = \mathrm{max} \p{ a + 1, b + 1 } & & \p{ \textrm{\( b \) is limit} } \\
    a \bo{ n } b & = \sup_{ b' < b } \p{ a \bo{ n } b' } & & \p{ \textrm{\( b \) is limit} \wedge 1 \leq n } \\
  \end{align}
\]</nowiki>

この演算子の値は次のようになる。

* \( \omega \bo{ \omega } 0 = 1 \)
* \( \omega \bo{ \omega + 1 } 0 = 1 \)
* \( \omega \bo{ \omega } 1 = \sup_{ n' < n } \p{ \omega \bo{ n' } \p{ \omega \bo{ \omega } 0 } } = \sup_{ n' < n } \p{ \omega \bo{ n' } 1 } = \varphi_\omega \p{ 0 } \)
* \( \omega \bo{ \omega } 2 = \sup_{ n' < n } \p{ \p{ \omega \bo{ \omega } 1 } \bo{ n' } \omega } = \varphi_\omega \p{ 1 } \)
* \( \omega \bo{ \omega } 3 = \sup_{ n' < n } \p{ \p{ \omega \bo{ \omega } 2 } \bo{ n' } \omega } = \varphi_\omega \p{ 2 } \)
* \( \omega \bo{ \omega } \omega = \varphi_\omega \p{ \omega } \)
* \( \omega \bo{ \omega } \p{ \omega + 1 } = \sup_{ n' < n } \p{ \p{ \omega \bo{ \omega } \omega } \bo{ n' } \omega } = \varphi_\omega \p{ \omega + 1 } \)
* \( \omega \bo{ \omega } \p{ \omega + \omega } = \varphi_\omega \p{ \omega + \omega } \)
* \( \p{ \omega \bo{ \omega } \omega } \bo{ \omega } \omega = \varphi_\omega \p{ \omega + \omega } \)
* \( \omega \bo{ \omega } \p{ \omega \bo{ \omega } 1 } = \varphi_\omega \p{ \varphi_\omega \p{ 0 } } \)
* \( \omega \bo{ \omega + 1 } 1 = \omega \bo{ \omega } \p{ \omega \bo{ \omega + 1 } 0 } = \varphi_\omega \p{ \varphi_\omega \p{ 0 } } \)
* \( \omega \bo{ \omega } \p{ \omega \bo{ \omega } \omega } = \varphi_\omega \p{ \varphi_\omega \p{ \omega } } \)
* \( \omega \bo{ \omega + 1 } 2 = \omega \bo{ \omega } \p{ \omega \bo{ \omega + 1 } 1 } = \varphi_\omega \p{ \varphi_\omega \p{ \varphi_\omega \p{ 0 } } } \)
* \( \omega \bo{ \omega + 1 } \omega = \varphi_{ \omega + 1 } \p{ 0 } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega + 1 } = \varphi_\omega \p{ \varphi_{ \omega + 1 } \p{ 0 } + 1 } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega + 2 } = \varphi_\omega \p{ \varphi_\omega \p{ \varphi_{ \omega + 1 } \p{ 0 } + 1 } } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega + \omega } = \varphi_{ \omega + 1 } \p{ 1 } \)
* \( \omega \bo{ \omega + 1 } \p{ \omega \bo{ \omega + 1 } \omega } = \varphi_{ \omega + 1 } \p{ \varphi_{ \omega + 1 } \p{ 0 } } \)
* \( \omega \bo{ \omega + 2 } \omega = \varphi_{ \omega + 2 } \p{ 0 } \)
* \( \omega \bo{ \omega + \omega } 1 = \varphi_{ \omega + \omega } \p{ 0 } \)
* \( \omega \bo{ \omega + \omega } \omega = \varphi_{ \omega + \omega } \p{ \omega } \)
* \( \omega \bo{ \omega + \omega } \p{ \omega \bo{ \omega + \omega } 1 } = \varphi_{ \omega + \omega } \p{ \varphi_{ \omega + \omega } \p{ 0 } } \)
* \( \omega \bo{ \omega + \omega + 1 } \omega = \varphi_{ \omega + \omega + 1 } \p{ 0 } \)
* \( \omega \bo{ \omega \bo{ \omega } \omega } \omega = \varphi_{ \varphi_\omega \p{ \omega } } \p{ \omega } \)
* \( \omega \bo{ \omega \bo{ \omega \bo{ \omega } \omega } \omega } \omega = \varphi_{ \varphi_{ \varphi_\omega \p{ \omega } } \p{ \omega } } \p{ \omega } \)

表記の限界は \( \Gamma_0 \) となる。

== 今後の展望 ==

この記事では、ハイパー演算子を順序数に拡張した。その結果として、超限ハイパー演算子はヴェブレン階層と大まかに対応することが判明した。今後の方向性として、超限ハイパー演算子の階数を多変数化して、多変数ヴェブレン関数と対応させることを、私は構想している。

ハイパー演算子は、現在の巨大数研究において主流な分野と比べると、あまりにもその大きさが小さい表記であるが、まだまだ面白い研究の余地はあると、私は信じている。

== 関連記事 ==

# [[ユーザーブログ:Hexirp/ハイパー演算子の拡張|ハイパー演算子の拡張]]
# [[ユーザーブログ:Hexirp/超限ハイパー演算子の解析|超限ハイパー演算子の解析]]
# [[ユーザーブログ:Hexirp/数符「トランスウィークハイパー」|数符「トランスウィークハイパー」]]

[[カテゴリ:ブログ記事]]
