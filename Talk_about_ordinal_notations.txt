順序数表記について話す。私は構成主義に近い立場だと自分で思っており、この文章にもそれが反映されているだろう。特に集合ではなく型をベースにして思考していることが多いのに注意してほしい。

私は、今のところ順序数表記を重視している。その理由は思い付くものでは「定義が厳密である」というものがある。定義が厳密であることは大前提であるが、それを満たすようなシステムはまだ選択の余地がある。他の巨大数を生成するシステムを取り上げて比較してみる。

まず、超越整数は計算可能であり大きさも申し分ない。しかし、その大きさの下限や上限に関する情報は少ないように見え、具体性が欠けているように思える。次に、ビジービーバー関数に類するものは、定義が具体的であり弱い理論でも well-defined であることが証明できるが、計算不可能である。興味深いと思うが、今は順序数表記を学んでいる途中であり、後回しにしたい。次に、巨大庭園数に類するものは、強い理論の中で定義されるものであり計算不可能である。これも興味深いが後回しにする。

つまり、以前より順序数表記を勉強していて、一定の結果を出せるようになったので、私は順序数表記を重視しているということになる。

== 順序数表記の定義 ==

...

== 順序数表記の定義に関するテクニック ==

順序数表記の定義をする際に、私が考案したテクニックが二つある。それらは[https://googology.wikia.org/ja/wiki/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%83%96%E3%83%AD%E3%82%B0:Hexirp/%E8%A7%A3%E6%9E%90_(i_LoVe_Ordinal) 解析_(i_LoVe_Ordinal)] において完成を見た。

一つ目は、単項と加算列での相互再帰である。私が見る限り Googology Wiki に記載されている順序数表記の多くは単項と加算を一つの型（集合）で表している。その一例は [https://googology.wikia.org/wiki/Buchholz%27s_function?oldid=278444 Buchholz's function (the revision on 2020-02-16)] にある。しかしながら、これは、項を二つの場合に分ける必要が出てくることになり、比較や基本列の定義が複雑になってしまう。そこで単項 (additively indecomposable ordinal) と加算列の二つへと最初から分ける。

この場合の単項は、加算列へと関数を適用した結果である。そのような関数には \( x \mapsto \omega ^ x \) や \( ( x, y ) \mapsto \varphi _ x ( y ) \) などがある。また、順序数崩壊関数を元にしている場合は、その順序数崩壊関数自体も関数の一つに数えられる。さらに、関数に引数がない場合は定数となり、その例として \( \Omega \) などが挙げられる。

この場合の加算列は、単項の列である。要素の数はゼロでもよく、その場合は最小元であるところの 0 に対応することになる。その構造は Haskell のリストと同じである。
