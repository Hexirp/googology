申し訳ないのですが、全体的によくわかりませんでした……

> 2階なら関係記号を量化すれば

ここでいう関係記号は二つの順序数を取る述語ということですか。

二階述語論理は、元としている一階述語論理の対象をAとした時、「Aを要素とする集合を対象に組み入れて量化できるようにし、帰属関係を言語に追加する」か「Aを一つ受け取る述語を対象に組み入れて量化できるようにし、述語の適用を言語に追加する」のいずれかであると私は思っていました。Aを二つ受け取る述語を対象に組み入れるのも二階述語論理に含むのでしょうか。あるいはそう見做せるようにする方法が存在するのでしょうか。

この記事で二階述語論理と呼んでいるのは、実のところ、Aを対象とする一階述語論理に、Aを一つ受け取ってAを返す関数を対象に組み入れ、関数の適用を言語に追加するような論理に対して、どう呼べばいいのか分からないため仮名として付けたものです。なので、この記事の論理でAを受け取る述語を直接的に扱うのはたぶんできないかと思います。

> 2階なら関係記号を量化すれば実質部分集合を量化出来る

この部分は、「Aを二つ受け取る述語を対象に組み入れて量化できるようにし、述語の適用を言語に追加する」二階述語論理が、「Aを要素とする集合を対象に組み入れて量化できるようにし、帰属関係を言語に追加する」二階述語論理を含むという意味だと解釈をしました。

> 実質部分集合を量化出来るので、より大きいものの存在と上限の存在を１つにまとめてもっとシンプルに出来ますよ。

どうして部分集合を量化できると「より大きいものの存在」と「上限の存在」を一つにまとめることができるのでしょうか。

∀x. ∀S. ∃y. ∀z. z < x /\ z ∈ S -> z < y

上のような公理を追加することでしょうか。しかし、これでは 1 を定義するために一元集合が必要になり、それは 1 からしか作れないという状態になります。なので、この公理は想定している方法とはたぶん異なると思います。

> 任意の部分集合に対する数え上げ関数の存在

申し訳ないのですが、私の知識が足りず、具体的にこれが何なのか分かりません。

例えば ω の部分集合を ∀x. x < ω -> f ( x ) < 2 を満たす関数 f で定義した時、それと濃度が等しい基数 a と、それを数え上げる ∀x. x < a -> f ( g ( x ) ) = 1 を満たす関数 g と、そしてそれらでさらに ∀x. ∀y. x < a /\ y < a /\ x < y -> g ( x ) < g ( y ) を満たすものが存在する、というような命題のことでしょうか。

====

私が前提にしていた考え：

: 二階述語論理は、Aを対象とする一階述語論理をベースとして、「Aを要素とする集合を対象に組み入れて量化できるようにし、帰属関係を言語に追加した」ものが基本である。別種として「Aを一つ受け取る述語を対象に組み入れて量化できるようにし、述語の適用を言語に追加した」ものがある。前者と後者は等価なので問題ない。
: そのため、「Aを一つ受け取ってAを返す関数を対象に組み入れ、関数の適用を言語に追加する」ような論理は、二階述語論理とは言えない（言いづらい）。

実際：

: 二階述語論理は、個体の集合と、個体の k-項関係と、ドメインの k 個の元を引数として 1 つの元を値とする関数を扱うことができる。

私の初歩的な誤りにより迷惑をかけてしまい申し訳ございません。

----

> ∀R,∃s,(∀x,R(x)→x<s)∧(∀y,(∀x,R(x)→x<y)→(s=y∨s<y))

この公理を加えてみます。まず R ( x ) := ∀y. y = y とします。このとき ∀x. R ( x ) -> x < s を満たす s が存在します。 s を代入して R ( s ) -> s < s とします。 R は引数に関わらず真なので s < s となります。これは、整礎帰納法の公理に矛盾します。

----

> > 例えば ω の部分集合を ∀x. x < ω -> f ( x ) < 2 を満たす関数 f で定義した時

> 何でωの部分集合を関数で定義できるのでしょうか？　関数が定義できるのはω^2の部分集合ですよね。

f : ω -> 2 で ω の部分集合を表現しようとしています。一般的に f : a -> b は ∀x. x < a -> f ( x ) < b と表現できると思っています。

----

> 僕が言っているのは「任意の部分集合S⊂Aに対し、あるα,β∈Aとf:α→βが存在して、fがSの数え上げとなる（fがSへの順序保存同型である）」という主張です。

なるほど、 ∀a. ∀S. (∀x. x ∈ S -> x < a) -> ∃α. ∃β. ∃f. α < a /\ β < a /\ (∀x. x < α -> f ( x ) < β) /\ (∀x. x < α -> x ∈ S) /\ (∀x. ∀y. x < α /\ y < α /\ x < y -> f ( x ) < f ( y ) ) となるでしょうか。ただ、これで本当に順序保存同型なのかはわかりません（準同型にしかならない？）ので、もう少し考えてみます。

ただ、 A を基数として | S | = A としたとき、それは偽になるように見えます。

----

本当に申し訳ございません。
