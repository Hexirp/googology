[https://googology.wikia.org/ja/wiki/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%83%96%E3%83%AD%E3%82%B0:Seruranblue/sikigamig_entry?oldid=23186 ユーザーブログ:Seruranblue/sikigamig_entry]を解析する。

== 解析 ==

有効かどうか確かめる。

* <code>main</code> の前に <code>int</code> がないが大丈夫か？
** 古い C 言語の仕様では、暗黙の <code>int</code> が許されている。現在のコンパイラーでも警告を出すがエラーは出さないものがある。
* <code>for</code> 文を改行なしで重ねて大丈夫か？
** 大丈夫。
* スペースとタブが混在しているが大丈夫か？
** 大丈夫。
* <code><nowiki>#include <stdio.h></nowiki></code> がないが大丈夫か？
** 大丈夫。
* チェックには何を使った？
** [https://repl.it/languages/c Repl.it] 。
* 数値をそのまま外に返しているけど大丈夫？
** このくらいなら認める。

値を求める。

<pre>
#include <stdio.h>

#define A for(b=a;b!=0;b--){a<<=9;}

main(){
    int a=1,b;
    A
	printf("%d\n", a);
  return 0;
}
</pre>

<code>a<<=9;</code> が一つ実行されるたびに <code>a</code> の値は \( 2 ^ 9 \) 倍になる。たとえば、上記のプログラムが表示する値は \( 512 \) になる。

<code>A</code> は <code>a<<=9;</code> を <code>b</code> 回実行する。ここで <code>b</code> はループを開始した時の <code>a</code> に等しい。すなわち、 <code>a</code> が指す値が \( x \) であるとき、 <code>A</code> を実行し終えた時の <code>a</code> の値は（オーバーフローがなければ） \( x \times { ( 2 ^ 9 ) } ^ x \) である。すなわち、 \( x \times 2 ^ { 9 x } \) である。これは上記のプログラムの結果と一致している。

\[ f ( x ) = x \times 2 ^ { 9 x } \]

上記のように関数 \( f \) を定義する。 \( f \) は狭義単調な関数同士の積であるため狭義単調である。

\( { ( f ^ a ) } ^ b ( x ) = f ^ { a b } ( x ) \) である。これより、まず <code>B</code> は \( x \mapsto f ^ { 10 } ( x ) \) に等しく、 <code>C</code> は \( x \mapsto f ^ { { 10 } ^ 2 } ( x ) \) である。さらに、 <code>D</code> は \( x \mapsto f ^ { { 10 } ^ 3 } ( x ) \) と続き、最終的に <code>Y</code> は \( x \mapsto f ^ { { 10 } ^ { 25 } } ( x ) \) である。

<code>output-2.c</code> が計算する値は \( f ^ { { 10 } ^ { 25 } } ( 1 ) \) である。

=== 近似 ===

関数を見るとテトレーションレベルであると目途が付く。

最初に 2 を底とするテトレーションで極めて大雑把な近似を行うことを試みる。

\[ \exp _ b ^ n ( a ) = \begin{cases} a & ( n = 0 ) \\ \exp _ b ( \exp _ b ^ { n' } ( a ) ) & ( n = n' + 1 ) \\ \end{cases} \]

上記のような関数を導入する。これは指数のタワーを使いやすく表記するものである。

\[ 1 \le x \Longrightarrow 2 ^ x \le f ( x ) = x \times 2 ^ { 9 x } \tag{1} \]

'''証明）'''まず、 \( 1 \le x \rightarrow 2 ^ { 9 x } \le x \times 2 ^ { 9 x } \) である。次に、 \( 0 \le x \rightarrow x \le 9 x \) であるから \( 0 \le x \rightarrow 2 ^ x \le 2 ^ { 9 x } \) である。この二つを合わせて \( 1 \le x \rightarrow 2 ^ x \le x \times 2 ^ { 9 x } \) である。

\[ 6 \le x \Longrightarrow f ( x ) = x \times 2 ^ { 9 x } \le 2 ^ { 2 ^ x } \tag{2} \]

{{User:Hexirp/tcu}}
'''証明）'''
{{User:Hexirp/tcm}}
ここは数学的帰納法を使う。

まず、 \( x = 6 \) である時を考える。すると、左辺は \( 6 \times 2 ^ { 9 \times 6 } = 6 \times 2 ^ { 54 } \le 8 \times 2 ^ { 54 } = 2 ^ { 57 } \) と概算できる。右辺は \( 2 ^ { 2 ^ 6 } = 2 ^ { 64 } \) である。ゆえに、 \( 6 \times 2 ^ { 6 \times 6 } \le 2 ^ { 2 ^ 6 } \) である。

次に、 \( x = n \) である場合に式が正しいと仮定した上で \( x = n + 1 \) であるときを考える。
{{User:Hexirp/tcl}}

この式は [https://www.wolframalpha.com/input/?i=2%5E%282%5Ex%29%3Dx*2%5E%286x%29&lang=ja Wolfram Alpha の結果]を参考にして立てた。また、両辺の対数を取るとより厳密な値を計算してくれる（[https://www.wolframalpha.com/input/?i=2%5Ex%3Dlog_2%28x*2%5E%286x%29%29&lang=ja 結果]）。

== 結果 ==

……
