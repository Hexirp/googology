この記事では私が考案したハイパー演算子の拡張を三つ紹介する。これらは普遍的な考え方を使ったものであるため同じものが別の人により考え出されている可能性が高い。

この記事で元になっている[[ハイパー演算子]]はゼロでない自然数 <math> a, b, n </math> に対して以下のように定義される自然数を返す関数である。

<math>
  a \langle n \rangle b =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a \langle n \rangle b' ) + 1, & \text{if} \quad b = b' + 1 \land n = 1 \\
      a \langle n' \rangle ( a \langle n \rangle b' ), & \text{if} \quad b = b' + 1 \land n = n' + 1
    \end{cases}
</math>

また、弱ハイパー演算子も同様の定義域において以下のように定義される。

<math>
  a [ n ] b =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a [ n ] b' ) + 1, & \text{if} \quad b = b' + 1 \land n = 1 \\
      ( a [ n ] b' ) [ n' ] a, & \text{if} \quad b = b' + 1 \land n = n' + 1
    \end{cases}
</math>

== 多変数ハイパー演算子 ==

[[多変数アッカーマン関数]]は既に定義されているが、多変数ハイパー演算子は明確な定義を見たことがない。ここで定義を明示しておくことは役に立つと思う。最初に2変数版を以下に示す。この関数は ゼロではない自然数 <math> a, b </math> と自然数 <math> m, n </math> に対して、 <math> m, n </math> が両方ともゼロである場合を除いて定義されている。

<math>
  a \langle m, n \rangle =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a \langle m, n \rangle b) + 1, & \text{if} \quad b = b' + 1 \land m = 0 \land n = 1 \\
      a \langle m', b \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = 0 \\
      a \langle m, n' \rangle ( a \langle m, n \rangle b' ), & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1
    \end{cases}
</math>

同様の拡張を繰り返して多変数化が可能である。

<math>
  a \langle m, n, o \rangle =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a \langle m, n, o \rangle b) + 1, & \text{if} \quad b = b' + 1 \land m = 0 \land n = 0 \land o = 1 \\
      a \langle m', b, o \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = 0 \land o = 0 \\
      a \langle m, n', b \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1 \land o = 0 \\
      a \langle m, n, o' \rangle ( a \langle m, n, o \rangle b' ), & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1 \land o = o' + 1
    \end{cases}
</math>

<math>
  a \langle m, n, o, p \rangle =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a \langle m, n, o, p \rangle b) + 1, & \text{if} \quad b = b' + 1 \land m = 0 \land n = 0 \land o = 0 \land p = 1 \\
      a \langle m', b, o, p \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = 0 \land o = 0 \land p = 0 \\
      a \langle m, n', b, p \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1 \land o = 0 \land p = 0 \\
      a \langle m, n, o', b \rangle b, & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1 \land o = o' + 1 \land p = 0 \\
      a \langle m, n, o, p' \rangle ( a \langle m, n, o, p \rangle b' ), & \text{if} \quad b = b' + 1 \land m = m' + 1 \land n = n' + 1 \land o = o' + 1 \land p = p' + 1
    \end{cases}
</math>

== ハイパー階層 ==

多変数ハイパー演算子は <math> \omega ^ \omega </math> までの急増加関数の動作をまねて作っている。同様の考え方でより大きい順序数にも拡張できる。

<math>
  x \langle \alpha \rangle y =
    \begin{cases}
      x, & \text{if} \quad y = 1 \\
      ( x \langle \alpha \rangle y' ) + 1, & \text{if} \quad y = y' + 1 \land \alpha = 1 \\
      x \langle \alpha' \rangle ( x \langle \alpha \rangle y' ), & \text{if} \quad y = y' + 1 \land \alpha = \alpha' + 1 \\
      x \langle \alpha [ y ] \rangle y, & \text{if} \quad y = y' + 1 \land \mathbf{Limit} ( \alpha )
    \end{cases}
</math>

== 超限ハイパー演算子 ==

ハイパー演算子に極限順序数に対しては極限をとるというルールを追加することでゼロ以外の順序数全体へ定義域を拡張することができる。しかし、これは <math> \omega \langle 4 \rangle \omega = \epsilon_0 </math> を超えると増加しなくなるという欠点を抱えている。

<math>
  a \langle n \rangle b =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a \langle n \rangle b' ) + 1, & \text{if} \quad b = b' + 1 \land n = 1 \\
      a \langle n' \rangle ( a \langle n \rangle b' ), & \text{if} \quad b = b' + 1 \land n = n' + 1 \\
      \sup \{ a \langle n' \rangle \mid n' < n \land n' \neq 0 \}, & \text{if} \quad b = b' + 1 \land \mathbf{Limit} ( n ) \\
      \sup \{ a \langle n \rangle b' \mid b' < b \land b' \neq 0 \}, & \text{if} \quad \mathbf{Limit} ( b )
    \end{cases}
</math>

弱ハイパー演算子に同様の拡張を施すと <math> \epsilon_0 </math> を超えても増加しつづける。

<math>
  a [ n ] b =
    \begin{cases}
      a, & \text{if} \quad b = 1 \\
      ( a [ n ] b' ) + 1, & \text{if} \quad b = b' + 1 \land n = 1 \\
      ( a [ n ] b' ) [ n' ] a, & \text{if} \quad b = b' + 1 \land n = n' + 1 \\
      \sup \{ a [ n' ] b \mid n' < n \land n' \neq 0 \}, & \text{if} \quad b = b' + 1 \land \mathbf{Limit} ( n ) \\
      \sup \{ a [ n ] b' \mid b' < b \land b' \neq 0 \}, & \text{if} \quad \mathbf{Limit} ( b )
    \end{cases}
</math>

== ゼロに対する値 ==

ハイパー演算子とその拡張は引数にゼロが与えられている場合にも整合的なある値を設定できる。以下の恒等式を満たすように定めればよい。

<math> a \langle n \rangle ( a \langle n + 1 \rangle 0 ) = a \langle n + 1 \rangle 1 = a </math>

しかし、弱ハイパー演算子では整合的に定義できない。ハイパー演算子におけるテトレーションレベルになると期待される性質を満たすような自然数が存在しなくなってしまうからだ。

<math> ( a [ n ] 0 ) [ n + 1 ] a = a [ n + 1 ] 1 = a </math>
